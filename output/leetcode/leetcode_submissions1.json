{
    "submissions_dump": [
      {
         "id": 595303064,
         "lang": "javascript",
         "time": "0 minutes",
         "timestamp": 1638339633,
         "status_display": "Accepted",
         "runtime": "76 ms",
         "url": "/submissions/detail/595303064/",
         "is_pending": "Not Pending",
         "title": "Two Sum",
         "memory": "40.6 MB",
         "code": "// Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\n// You may assume that each input would have exactly one solution, and you may not use the same element twice.\n\n// You can return the answer in any order.\n\n\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\n var twoSum = function(nums, target) {\n         let hash = {};\n    for (let i = 0; i < nums.length; i++) {\n        let complement = target - nums[i];\n        if (hash[complement] !== undefined) {\n            return [hash[complement], i];\n        }\n        hash[nums[i]] = i;\n    }  \n};",
         "compare_result": "111111111111111111111111111111111111111111111111111111111",
         "title_slug": "two-sum"
      },
      {
         "id": 595302855,
         "lang": "c",
         "time": "1 minute",
         "timestamp": 1638339606,
         "status_display": "Accepted",
         "runtime": "80 ms",
         "url": "/submissions/detail/595302855/",
         "is_pending": "Not Pending",
         "title": "Two Sum",
         "memory": "6.5 MB",
         "code": "// Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\n// You may assume that each input would have exactly one solution, and you may not use the same element twice.\n\n// You can return the answer in any order.\n\n\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* twoSum(int* nums, int numsSize, int target, int* returnSize){\n    int *result = malloc(sizeof(int) * 2);\n    *returnSize = 2;\n    int i, j;\n    for (i = 0; i < numsSize; i++) {\n        for (j = i + 1; j < numsSize; j++) {\n            if (nums[i] + nums[j] == target) {\n                result[0] = i;\n                result[1] = j;\n                return result;\n            }\n        }\n    }\n    return result;\n}",
         "compare_result": "111111111111111111111111111111111111111111111111111111111",
         "title_slug": "two-sum"
      },
      {
         "id": 595302548,
         "lang": "java",
         "time": "1 minute",
         "timestamp": 1638339567,
         "status_display": "Accepted",
         "runtime": "1 ms",
         "url": "/submissions/detail/595302548/",
         "is_pending": "Not Pending",
         "title": "Two Sum",
         "memory": "39.1 MB",
         "code": "// Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\n// You may assume that each input would have exactly one solution, and you may not use the same element twice.\n\n// You can return the answer in any order.\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        throw new IllegalArgumentException(\"No two sum solution\");\n    }\n}",
         "compare_result": "111111111111111111111111111111111111111111111111111111111",
         "title_slug": "two-sum"
      },
      {
         "id": 595302088,
         "lang": "python",
         "time": "2 minutes",
         "timestamp": 1638339508,
         "status_display": "Accepted",
         "runtime": "3780 ms",
         "url": "/submissions/detail/595302088/",
         "is_pending": "Not Pending",
         "title": "Two Sum",
         "memory": "14.5 MB",
         "code": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(0,len(nums)):\n            for j in range(i+1,len(nums)):\n                if (nums[j]==target-nums[i]): return [i,j]",
         "compare_result": "111111111111111111111111111111111111111111111111111111111",
         "title_slug": "two-sum"
      },
      {
          "id": 595248126,
          "lang": "javascript",
          "time": "1 hour, 31 minutes",
          "timestamp": 1638332202,
          "status_display": "Wrong Answer",
          "runtime": "N/A",
          "url": "/submissions/detail/595248126/",
          "is_pending": "Not Pending",
          "title": "Unique Substrings in Wraparound String",
          "memory": "N/A",
          "code": "/** https://leetcode.com/problems/unique-substrings-in-wraparound-string/ */\n//We define the string s to be the infinite wraparound string of \"abcdefghijklmnopqrstuvwxyz\", so s will look like this:\n//\"...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....\".\n//Given a string p, return the number of unique non-empty substrings of p are present in s.\n\n/**\n * @param {string} p\n * @return {number}\n */\n var findSubstringInWraproundString = function(p) {\n       let map = new Map();\n  let count = 0;\n  for (let i = 0; i < 26; i++) {\n    map.set(String.fromCharCode(97 + i), 1);\n  }\n  for (let i = 0; i < p.length; i++) {\n    if (p[i] !== p[i + 1]) {\n      count += map.get(p[i]);\n      map.set(p[i], 1);\n    } else {\n      let count = map.get(p[i]) + 1;\n      map.set(p[i], count);\n    }\n  }\n  return count;\n};\n    ",
          "compare_result": "100000000001000000000000000000000000000000010011100000000000000000000000000000000",
          "title_slug": "unique-substrings-in-wraparound-string"
       },
       {
          "id": 595248086,
          "lang": "c",
          "time": "1 hour, 31 minutes",
          "timestamp": 1638332196,
          "status_display": "Wrong Answer",
          "runtime": "N/A",
          "url": "/submissions/detail/595248086/",
          "is_pending": "Not Pending",
          "title": "Unique Substrings in Wraparound String",
          "memory": "N/A",
          "code": "/** https://leetcode.com/problems/unique-substrings-in-wraparound-string/ */\n//We define the string s to be the infinite wraparound string of \"abcdefghijklmnopqrstuvwxyz\", so s will look like this:\n//\"...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....\".\n//Given a string p, return the number of unique non-empty substrings of p are present in s.\n\n\n\nint findSubstringInWraproundString(char * p){\n    int n = strlen(p);\n    int *count = (int *)calloc(26, sizeof(int));\n    int max = 0;\n    for (int i = 0; i < n; i++) {\n        if (i > 0 && (p[i] - p[i - 1] == 1 || p[i] - p[i - 1] == -25)) {\n            max++;\n        } else {\n            max = 1;\n        }\n        count[p[i] - 'a'] = max;\n    }\n    int res = 0;\n    for (int i = 0; i < 26; i++) {\n        res += count[i];\n    }\n    return res;\n}\n    ",
          "compare_result": "111011111011111111111111111111111111111111111111100100000000000000000000000000011",
          "title_slug": "unique-substrings-in-wraparound-string"
       },
       {
          "id": 595248015,
          "lang": "python",
          "time": "1 hour, 32 minutes",
          "timestamp": 1638332186,
          "status_display": "Wrong Answer",
          "runtime": "N/A",
          "url": "/submissions/detail/595248015/",
          "is_pending": "Not Pending",
          "title": "Unique Substrings in Wraparound String",
          "memory": "N/A",
          "code": "# https://leetcode.com/problems/unique-substrings-in-wraparound-string/\n#We define the string s to be the infinite wraparound string of \"abcdefghijklmnopqrstuvwxyz\", so s will look like this:\n#\"...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....\".\n#Given a string p, return the number of unique non-empty substrings of p are present in s.\n\nclass Solution(object):\n    def findSubstringInWraproundString(self, p):\n        \"\"\"\n        :type p: str\n        :rtype: int\n        \"\"\"\n        if not p:\n            return 0\n        d = {}\n        for i in range(len(p)):\n            if i == 0:\n                d[p[i]] = 1\n            else:\n                if ord(p[i]) - ord(p[i - 1]) == 1 or ord(p[i]) - ord(p[i - 1]) == -25:\n                    d[p[i]] = d[p[i - 1]] + 1\n                else:\n                    d[p[i]] = 1\n        return sum(d.values())    \n    ",
          "compare_result": "111011111011111111111111111111111111111111111111100100000000000000000000000000011",
          "title_slug": "unique-substrings-in-wraparound-string"
       },
       {
          "id": 595247920,
          "lang": "java",
          "time": "1 hour, 32 minutes",
          "timestamp": 1638332171,
          "status_display": "Wrong Answer",
          "runtime": "N/A",
          "url": "/submissions/detail/595247920/",
          "is_pending": "Not Pending",
          "title": "Unique Substrings in Wraparound String",
          "memory": "N/A",
          "code": "/** https://leetcode.com/problems/unique-substrings-in-wraparound-string/ */\n//We define the string s to be the infinite wraparound string of \"abcdefghijklmnopqrstuvwxyz\", so s will look like this:\n//\"...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....\".\n//Given a string p, return the number of unique non-empty substrings of p are present in s.\n\nclass Solution {\n    public int findSubstringInWraproundString(String p) {\n        int[] count = new int[26];\n        int max = 0;\n        for (int i = 0; i < p.length(); i++) {\n            char c = p.charAt(i);\n            if (i > 0 && (p.charAt(i - 1) - c + 26) % 26 == 1) {\n                max++;\n            } else {\n                max = 1;\n            }\n            count[c - 'a'] = Math.max(count[c - 'a'], max);\n        }\n        int res = 0;\n        for (int i = 0; i < 26; i++) {\n            res += count[i];\n        }\n        return res;\n    }\n}",
          "compare_result": "110001100011000000000000000000000000000110101100100000000000000000000000000000000",
          "title_slug": "unique-substrings-in-wraparound-string"
       },
       {
          "id": 595247854,
          "lang": "c",
          "time": "1 hour, 32 minutes",
          "timestamp": 1638332161,
          "status_display": "Wrong Answer",
          "runtime": "N/A",
          "url": "/submissions/detail/595247854/",
          "is_pending": "Not Pending",
          "title": "Unique Substrings in Wraparound String",
          "memory": "N/A",
          "code": "/** https://leetcode.com/problems/unique-substrings-in-wraparound-string/ */\n//We define the string s to be the infinite wraparound string of \"abcdefghijklmnopqrstuvwxyz\", so s will look like this:\n//\"...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....\".\n//Given a string p, return the number of unique non-empty substrings of p are present in s.\n\n\n\nint findSubstringInWraproundString(char * p){\n    int n = strlen(p);\n    int *count = (int *)calloc(26, sizeof(int));\n    int max = 0;\n    for (int i = 0; i < n; i++) {\n        if (i > 0 && (p[i] - p[i - 1] == 1 || p[i] - p[i - 1] == -25)) {\n            max++;\n        } else {\n            max = 1;\n        }\n        count[p[i] - 'a'] = max;\n    }\n    int res = 0;\n    for (int i = 0; i < 26; i++) {\n        res += count[i];\n    }\n    return res;\n}\n    ",
          "compare_result": "111011111011111111111111111111111111111111111111100100000000000000000000000000011",
          "title_slug": "unique-substrings-in-wraparound-string"
       },
       {
          "id": 595247747,
          "lang": "python",
          "time": "1 hour, 32 minutes",
          "timestamp": 1638332146,
          "status_display": "Accepted",
          "runtime": "112 ms",
          "url": "/submissions/detail/595247747/",
          "is_pending": "Not Pending",
          "title": "Ugly Number II",
          "memory": "13.5 MB",
          "code": "# https://leetcode.com/problems/ugly-number-ii/\n\nclass Solution(object):\n    def nthUglyNumber(self, n):\n        \"\"\"\n        An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.\n        Given an integer n, return the nth ugly number.\n        :type n: int\n        :rtype: int\n        \"\"\"\n        ugly = [1]\n        i2, i3, i5 = 0, 0, 0\n        while len(ugly) < n:\n            u2, u3, u5 = 2 * ugly[i2], 3 * ugly[i3], 5 * ugly[i5]\n            umin = min(u2, u3, u5)\n            if umin == u2:\n                i2 += 1\n            if umin == u3:\n                i3 += 1\n            if umin == u5:\n                i5 += 1\n            ugly.append(umin)\n        return ugly[-1]        ",
          "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
          "title_slug": "ugly-number-ii"
       },
       {
          "id": 595247676,
          "lang": "c",
          "time": "1 hour, 32 minutes",
          "timestamp": 1638332139,
          "status_display": "Compile Error",
          "runtime": "N/A",
          "url": "/submissions/detail/595247676/",
          "is_pending": "Not Pending",
          "title": "Ugly Number II",
          "memory": "N/A",
          "code": "/** https://leetcode.com/problems/ugly-number-ii/ */\n\n/**\n * An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.\n * Given an integer n, return the nth ugly number.\n */\nint nthUglyNumber(int n){\n    int ugly[n];\n    ugly[0] = 1;\n    int i2 = 0, i3 = 0, i5 = 0;\n    for(int i = 1; i < n; i++){\n        ugly[i] = min(min(ugly[i2] * 2, ugly[i3] * 3), ugly[i5] * 5);\n        if(ugly[i] == ugly[i2] * 2) i2++;\n        if(ugly[i] == ugly[i3] * 3) i3++;\n        if(ugly[i] == ugly[i5] * 5) i5++;\n    }\n    return ugly[n - 1];\n}\n    ",
          "compare_result": null,
          "title_slug": "ugly-number-ii"
       },
       {
          "id": 595247265,
          "lang": "javascript",
          "time": "1 hour, 33 minutes",
          "timestamp": 1638332088,
          "status_display": "Wrong Answer",
          "runtime": "N/A",
          "url": "/submissions/detail/595247265/",
          "is_pending": "Not Pending",
          "title": "Super Ugly Number",
          "memory": "N/A",
          "code": "/** https://leetcode.com/problems/super-ugly-number/ */\n//A super ugly number is a positive integer whose prime factors are in the array primes.\n//Given an integer n and an array of integers primes, return the nth super ugly number.\n//The nth super ugly number is guaranteed to fit in a 32-bit signed integer.\n\n/**\n * @param {number} n\n * @param {number[]} primes\n * @return {number}\n */\n var nthSuperUglyNumber = function(n, primes) {\n         let ugly = [1];\n    let index = [0];\n    for(let i = 1; i < n; i++) {\n        let min = Number.MAX_SAFE_INTEGER;\n        let minIndex = -1;\n        for(let j = 0; j < primes.length; j++) {\n            let temp = ugly[index[j]] * primes[j];\n            if(temp < min) {\n                min = temp;\n                minIndex = j;\n            }\n        }\n        ugly[i] = min;\n        index[minIndex]++;\n    }\n    return ugly[n-1]; \n};\n    ",
          "compare_result": "0110011110000000000000000000000000000000000000000000000000000000000000000000000000000",
          "title_slug": "super-ugly-number"
       },
       {
          "id": 595247180,
          "lang": "python",
          "time": "1 hour, 33 minutes",
          "timestamp": 1638332074,
          "status_display": "Time Limit Exceeded",
          "runtime": "N/A",
          "url": "/submissions/detail/595247180/",
          "is_pending": "Not Pending",
          "title": "Super Ugly Number",
          "memory": "N/A",
          "code": "# https://leetcode.com/problems/super-ugly-number/\n#A super ugly number is a positive integer whose prime factors are in the array primes.\n#Given an integer n and an array of integers primes, return the nth super ugly number.\n#The nth super ugly number is guaranteed to fit in a 32-bit signed integer.\n\nclass Solution(object):\n    def nthSuperUglyNumber(self, n, primes):\n        \"\"\"\n        :type n: int\n        :type primes: List[int]\n        :rtype: int\n        \"\"\"\n        ugly = [1]\n        index = [0] * len(primes)\n        while len(ugly) < n:\n            next_ugly_num = min(primes[i] * ugly[index[i]] for i in range(len(primes)))\n            ugly.append(next_ugly_num)\n            for i in range(len(primes)):\n                if primes[i] * ugly[index[i]] == next_ugly_num:\n                    index[i] += 1\n        return ugly[-1]",
          "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111000",
          "title_slug": "super-ugly-number"
       },
       {
          "id": 595247100,
          "lang": "java",
          "time": "1 hour, 34 minutes",
          "timestamp": 1638332063,
          "status_display": "Accepted",
          "runtime": "267 ms",
          "url": "/submissions/detail/595247100/",
          "is_pending": "Not Pending",
          "title": "Super Ugly Number",
          "memory": "40.7 MB",
          "code": "/** https://leetcode.com/problems/super-ugly-number/ */\n//A super ugly number is a positive integer whose prime factors are in the array primes.\n//Given an integer n and an array of integers primes, return the nth super ugly number.\n//The nth super ugly number is guaranteed to fit in a 32-bit signed integer.\n\nclass Solution {\n    public int nthSuperUglyNumber(int n, int[] primes) {\n        int[] ugly = new int[n];\n        ugly[0] = 1;\n        int[] index = new int[primes.length];\n        for (int i = 1; i < n; i++) {\n            int min = Integer.MAX_VALUE;\n            for (int j = 0; j < primes.length; j++) {\n                min = Math.min(min, primes[j] * ugly[index[j]]);\n            }\n            ugly[i] = min;\n            for (int j = 0; j < primes.length; j++) {\n                if (primes[j] * ugly[index[j]] == min) {\n                    index[j]++;\n                }\n            }\n        }\n        return ugly[n - 1];\n    }\n}",
          "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
          "title_slug": "super-ugly-number"
       },
       {
          "id": 595246960,
          "lang": "c",
          "time": "1 hour, 34 minutes",
          "timestamp": 1638332043,
          "status_display": "Compile Error",
          "runtime": "N/A",
          "url": "/submissions/detail/595246960/",
          "is_pending": "Not Pending",
          "title": "Super Ugly Number",
          "memory": "N/A",
          "code": "/** https://leetcode.com/problems/super-ugly-number/ */\n//A super ugly number is a positive integer whose prime factors are in the array primes.\n//Given an integer n and an array of integers primes, return the nth super ugly number.\n//The nth super ugly number is guaranteed to fit in a 32-bit signed integer.\n\n\n\nint nthSuperUglyNumber(int n, int* primes, int primesSize){\n    int* dp = malloc(sizeof(int) * n);\n    dp[0] = 1;\n    int* index = malloc(sizeof(int) * primesSize);\n    for (int i = 1; i < n; i++) {\n        dp[i] = INT_MAX;\n        for (int j = 0; j < primesSize; j++) {\n            dp[i] = min(dp[i], dp[index[j]] * primes[j]);\n        }\n        for (int j = 0; j < primesSize; j++) {\n            if (dp[i] == dp[index[j]] * primes[j]) {\n                index[j]++;\n            }\n        }\n    }\n    int result = dp[n - 1];\n    free(dp);\n    free(index);\n    return result;\n    \n}\n    ",
          "compare_result": null,
          "title_slug": "super-ugly-number"
       },
       {
          "id": 595246731,
          "lang": "javascript",
          "time": "1 hour, 34 minutes",
          "timestamp": 1638332011,
          "status_display": "Accepted",
          "runtime": "484 ms",
          "url": "/submissions/detail/595246731/",
          "is_pending": "Not Pending",
          "title": "Russian Doll Envelopes",
          "memory": "41.6 MB",
          "code": "/** https://leetcode.com/problems/russian-doll-envelops/ */\n//You are given a 2D array of integers envelopes where envelopes[i] = [wi, hi] represents the width and the height of an envelope.\n//One envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope's width and height.\n//Return the maximum number of envelopes you can Russian doll (i.e., put one inside the other).\n//Note: You cannot rotate an envelope.\n\n/**\n * @param {number[][]} envelopes\n * @return {number}\n */\n var maxEnvelopes = function(envelopes) {\n         if (envelopes.length === 0) {\n        return 0;\n    }\n    envelopes.sort((a, b) => {\n        if (a[0] === b[0]) {\n            return b[1] - a[1];\n        }\n        return a[0] - b[0];\n    });\n    let dp = new Array(envelopes.length);\n    dp[0] = 1;\n    let max = 1;\n    for (let i = 1; i < envelopes.length; i++) {\n        dp[i] = 1;\n        for (let j = 0; j < i; j++) {\n            if (envelopes[i][0] > envelopes[j][0] && envelopes[i][1] > envelopes[j][1]) {\n                dp[i] = Math.max(dp[i], dp[j] + 1);\n            }\n        }\n        max = Math.max(max, dp[i]);\n    }\n    return max;\n};\n    ",
          "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
          "title_slug": "russian-doll-envelopes"
       },
       {
          "id": 595246601,
          "lang": "python",
          "time": "1 hour, 35 minutes",
          "timestamp": 1638331991,
          "status_display": "Time Limit Exceeded",
          "runtime": "N/A",
          "url": "/submissions/detail/595246601/",
          "is_pending": "Not Pending",
          "title": "Russian Doll Envelopes",
          "memory": "N/A",
          "code": "# https://leetcode.com/problems/russian-doll-envelops/\n#You are given a 2D array of integers envelopes where envelopes[i] = [wi, hi] represents the width and the height of an envelope.\n#One envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope's width and height.\n#Return the maximum number of envelopes you can Russian doll (i.e., put one inside the other).\n#Note: You cannot rotate an envelope.\n\nclass Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not envelopes:\n            return 0\n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        dp = [1] * len(envelopes)\n        for i in range(1, len(envelopes)):\n            for j in range(i):\n                if envelopes[i][0] > envelopes[j][0] and envelopes[i][1] > envelopes[j][1]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)",
          "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111110",
          "title_slug": "russian-doll-envelopes"
       },
       {
          "id": 595246466,
          "lang": "java",
          "time": "1 hour, 35 minutes",
          "timestamp": 1638331973,
          "status_display": "Wrong Answer",
          "runtime": "N/A",
          "url": "/submissions/detail/595246466/",
          "is_pending": "Not Pending",
          "title": "Russian Doll Envelopes",
          "memory": "N/A",
          "code": "/** https://leetcode.com/problems/russian-doll-envelops/ */\n//You are given a 2D array of integers envelopes where envelopes[i] = [wi, hi] represents the width and the height of an envelope.\n//One envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope's width and height.\n//Return the maximum number of envelopes you can Russian doll (i.e., put one inside the other).\n//Note: You cannot rotate an envelope.\n\nclass Solution {\n    public int maxEnvelopes(int[][] envelopes) {\n        Arrays.sort(envelopes, (a, b) -> a[0] == b[0] ? b[1] - a[1] : a[0] - b[0]);\n        int[] dp = new int[envelopes.length];\n        int max = 0;\n        for (int i = 0; i < envelopes.length; i++) {\n            int height = envelopes[i][1];\n            int left = 0;\n            int right = max;\n            while (left <= right) {\n                int mid = (left + right) / 2;\n                if (dp[mid] < height) {\n                    left = mid + 1;\n                } else {\n                    right = mid - 1;\n                }\n            }\n            dp[left] = height;\n            if (left == max) {\n                max++;\n            }\n        }\n        return max;\n    }\n}",
          "compare_result": "000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
          "title_slug": "russian-doll-envelopes"
       },
       {
          "id": 595246262,
          "lang": "c",
          "time": "1 hour, 36 minutes",
          "timestamp": 1638331942,
          "status_display": "Compile Error",
          "runtime": "N/A",
          "url": "/submissions/detail/595246262/",
          "is_pending": "Not Pending",
          "title": "Russian Doll Envelopes",
          "memory": "N/A",
          "code": "/** https://leetcode.com/problems/russian-doll-envelops/ */\n//You are given a 2D array of integers envelopes where envelopes[i] = [wi, hi] represents the width and the height of an envelope.\n//One envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope's width and height.\n//Return the maximum number of envelopes you can Russian doll (i.e., put one inside the other).\n//Note: You cannot rotate an envelope.\n\n\n\nint maxEnvelopes(int** envelopes, int envelopesSize, int* envelopesColSize){\n    int max = 0;\n    int* dp = (int*)malloc(sizeof(int)*envelopesSize);\n    for(int i = 0; i < envelopesSize; i++){\n        dp[i] = 1;\n        for(int j = 0; j < i; j++){\n            if(envelopes[i][0] > envelopes[j][0] && envelopes[i][1] > envelopes[j][1]){\n                dp[i] = max(dp[i], dp[j] + 1);\n            }\n        }\n        max = max(max, dp[i]);\n    }\n    return max;\n}\n    ",
          "compare_result": null,
          "title_slug": "russian-doll-envelopes"
       },
       {
          "id": 595245886,
          "lang": "javascript",
          "time": "1 hour, 36 minutes",
          "timestamp": 1638331891,
          "status_display": "Accepted",
          "runtime": "96 ms",
          "url": "/submissions/detail/595245886/",
          "is_pending": "Not Pending",
          "title": "Rotate Function",
          "memory": "49.4 MB",
          "code": "/** https://leetcode.com/problems/rotate-function/ */\n//You are given an integer array nums of length n.\n//Assume arrk to be an array obtained by rotating nums by k positions clock-wise. We define the rotation function F on nums as follow:\n//F(k) = 0 * arrk[0] + 1 * arrk[1] + ... + (n - 1) * arrk[n - 1].\n//Return the maximum value of F(0), F(1), ..., F(n-1).\n//The test cases are generated so that the answer fits in a 32-bit integer.\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\n var maxRotateFunction = function(nums) {\n         let sum = 0;\n    let max = 0;\n    for(let i = 0; i < nums.length; i++) {\n        sum += nums[i];\n        max += nums[i] * i;\n    }\n    let cur = max;\n    for(let i = nums.length - 1; i >= 1; i--) {\n        cur = cur + sum - nums.length * nums[i];\n        max = Math.max(max, cur);\n    }\n    return max;\n}\n    ",
          "compare_result": "1111111111111111111111111111111111111111111111111111111111",
          "title_slug": "rotate-function"
       },
       {
          "id": 595245832,
          "lang": "python",
          "time": "1 hour, 37 minutes",
          "timestamp": 1638331883,
          "status_display": "Wrong Answer",
          "runtime": "N/A",
          "url": "/submissions/detail/595245832/",
          "is_pending": "Not Pending",
          "title": "Rotate Function",
          "memory": "N/A",
          "code": "# https://leetcode.com/problems/rotate-function/\n#You are given an integer array nums of length n.\n#Assume arrk to be an array obtained by rotating nums by k positions clock-wise. We define the rotation function F on nums as follow:\n#F(k) = 0 * arrk[0] + 1 * arrk[1] + ... + (n - 1) * arrk[n - 1].\n#Return the maximum value of F(0), F(1), ..., F(n-1).\n#The test cases are generated so that the answer fits in a 32-bit integer.\n\nclass Solution(object):\n    def maxRotateFunction(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if len(nums) == 0:\n            return 0\n        if len(nums) == 1:\n            return nums[0]\n        sum_nums = sum(nums)\n        sum_of_index = sum([i * nums[i] for i in range(len(nums))])\n        max_sum_of_index = sum_of_index\n        for i in range(1, len(nums)):\n            sum_of_index = sum_of_index + sum_nums - len(nums) * nums[-i]\n            max_sum_of_index = max(max_sum_of_index, sum_of_index)\n        return max_sum_of_index",
          "compare_result": "1011111111111111111111111111111111111111111111111111111111",
          "title_slug": "rotate-function"
       },
       {
          "id": 595245763,
          "lang": "java",
          "time": "1 hour, 37 minutes",
          "timestamp": 1638331873,
          "status_display": "Wrong Answer",
          "runtime": "N/A",
          "url": "/submissions/detail/595245763/",
          "is_pending": "Not Pending",
          "title": "Rotate Function",
          "memory": "N/A",
          "code": "/** https://leetcode.com/problems/rotate-function/ */\n//You are given an integer array nums of length n.\n//Assume arrk to be an array obtained by rotating nums by k positions clock-wise. We define the rotation function F on nums as follow:\n//F(k) = 0 * arrk[0] + 1 * arrk[1] + ... + (n - 1) * arrk[n - 1].\n//Return the maximum value of F(0), F(1), ..., F(n-1).\n//The test cases are generated so that the answer fits in a 32-bit integer.\n\nclass Solution {\n    public int maxRotateFunction(int[] nums) {\n        if (nums.length == 0) return 0;\n        int sum = 0;\n        for (int i = 0; i < nums.length; i++) {\n            sum += nums[i];\n        }\n        int max = sum;\n        int f = 0;\n        for (int i = 0; i < nums.length; i++) {\n            f += i * nums[i];\n        }\n        for (int i = 1; i < nums.length; i++) {\n            f = f + sum - nums.length * nums[nums.length - i];\n            max = Math.max(max, f);\n        }\n        return max;\n    }\n}",
          "compare_result": "1000111011111111100111111111111111110110110111111111111100",
          "title_slug": "rotate-function"
       },
       {
          "id": 595245723,
          "lang": "c",
          "time": "1 hour, 37 minutes",
          "timestamp": 1638331867,
          "status_display": "Accepted",
          "runtime": "140 ms",
          "url": "/submissions/detail/595245723/",
          "is_pending": "Not Pending",
          "title": "Rotate Function",
          "memory": "13.4 MB",
          "code": "/** https://leetcode.com/problems/rotate-function/ */\n//You are given an integer array nums of length n.\n//Assume arrk to be an array obtained by rotating nums by k positions clock-wise. We define the rotation function F on nums as follow:\n//F(k) = 0 * arrk[0] + 1 * arrk[1] + ... + (n - 1) * arrk[n - 1].\n//Return the maximum value of F(0), F(1), ..., F(n-1).\n//The test cases are generated so that the answer fits in a 32-bit integer.\n\n\n\nint maxRotateFunction(int* nums, int numsSize){\n    int sum = 0, max = 0;\n    for (int i = 0; i < numsSize; i++) {\n        sum += nums[i];\n        max += i * nums[i];\n    }\n    int res = max;\n    for (int i = numsSize - 1; i >= 0; i--) {\n        max = max + sum - numsSize * nums[i];\n        res = max > res ? max : res;\n    }\n    return res;\n}\n    ",
          "compare_result": "1111111111111111111111111111111111111111111111111111111111",
          "title_slug": "rotate-function"
       },
       {
          "id": 595245639,
          "lang": "javascript",
          "time": "1 hour, 37 minutes",
          "timestamp": 1638331855,
          "status_display": "Runtime Error",
          "runtime": "N/A",
          "url": "/submissions/detail/595245639/",
          "is_pending": "Not Pending",
          "title": "Poor Pigs",
          "memory": "N/A",
          "code": "/** https://leetcode.com/problems/poor-pigs/ */\n//There are buckets buckets of liquid, where exactly one of the buckets is poisonous. To figure out which one is poisonous, you feed some number of (poor) pigs the liquid to see whether they will die or not. Unfortunately, you only have minutesToTest minutes to determine which bucket is poisonous.\n//You can feed the pigs according to these steps:\n//Choose some live pigs to feed.\n//For each pig, choose which buckets to feed it. The pig will consume all the chosen buckets simultaneously and will take no time.\n//Wait for minutesToDie minutes. You may not feed any other pigs during this time.\n//After minutesToDie minutes have passed, any pigs that have been fed the poisonous bucket will die, and all others will survive.\n//Repeat this process until you run out of time.\n//Given buckets, minutesToDie, and minutesToTest, return the minimum number of pigs needed to figure out which bucket is poisonous within the allotted time.\n\nclass Solution {\n    public int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\n        return (int)Math.ceil(Math.log(buckets) / Math.log(minutesToTest / minutesToDie + 1));\n    }\n}\n    ",
          "compare_result": "00000000000000000",
          "title_slug": "poor-pigs"
       }
    ],
    "has_next": true,
    "last_key": "%7B%22pk%22%3A%20%7B%22N%22%3A%20%22595245639%22%7D%2C%20%22dt%22%3A%20%7B%22S%22%3A%20%222021-12-01T04%3A10%3A55.409023%2B0000%22%7D%2C%20%22sid%22%3A%20%7B%22N%22%3A%20%225508277%22%7D%7D"
 }