{
    "submissions_dump": [
       {
          "id": 595245578,
          "lang": "python",
          "time": "1 hour, 45 minutes",
          "timestamp": 1638331847,
          "status_display": "Accepted",
          "runtime": "8 ms",
          "url": "/submissions/detail/595245578/",
          "is_pending": "Not Pending",
          "title": "Poor Pigs",
          "memory": "13.5 MB",
          "code": "# https://leetcode.com/problems/poor-pigs/\n#There are buckets buckets of liquid, where exactly one of the buckets is poisonous. To figure out which one is poisonous, you feed some number of (poor) pigs the liquid to see whether they will die or not. Unfortunately, you only have minutesToTest minutes to determine which bucket is poisonous.\n#You can feed the pigs according to these steps:\n#Choose some live pigs to feed.\n#For each pig, choose which buckets to feed it. The pig will consume all the chosen buckets simultaneously and will take no time.\n#Wait for minutesToDie minutes. You may not feed any other pigs during this time.\n#After minutesToDie minutes have passed, any pigs that have been fed the poisonous bucket will die, and all others will survive.\n#Repeat this process until you run out of time.\n#Given buckets, minutesToDie, and minutesToTest, return the minimum number of pigs needed to figure out which bucket is poisonous within the allotted time.\n\nclass Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        pigs = 0\n        while (minutesToTest / minutesToDie + 1) ** pigs < buckets:\n            pigs += 1\n        return pigs",
          "compare_result": "11111111111111111",
          "title_slug": "poor-pigs"
       },
       {
          "id": 595245490,
          "lang": "java",
          "time": "1 hour, 45 minutes",
          "timestamp": 1638331835,
          "status_display": "Accepted",
          "runtime": "0 ms",
          "url": "/submissions/detail/595245490/",
          "is_pending": "Not Pending",
          "title": "Poor Pigs",
          "memory": "35.8 MB",
          "code": "/** https://leetcode.com/problems/poor-pigs/ */\n//There are buckets buckets of liquid, where exactly one of the buckets is poisonous. To figure out which one is poisonous, you feed some number of (poor) pigs the liquid to see whether they will die or not. Unfortunately, you only have minutesToTest minutes to determine which bucket is poisonous.\n//You can feed the pigs according to these steps:\n//Choose some live pigs to feed.\n//For each pig, choose which buckets to feed it. The pig will consume all the chosen buckets simultaneously and will take no time.\n//Wait for minutesToDie minutes. You may not feed any other pigs during this time.\n//After minutesToDie minutes have passed, any pigs that have been fed the poisonous bucket will die, and all others will survive.\n//Repeat this process until you run out of time.\n//Given buckets, minutesToDie, and minutesToTest, return the minimum number of pigs needed to figure out which bucket is poisonous within the allotted time.\n\nclass Solution {\n    public int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\n        return (int)Math.ceil(Math.log(buckets) / Math.log(minutesToTest / minutesToDie + 1));\n    }\n}\n    ",
          "compare_result": "11111111111111111",
          "title_slug": "poor-pigs"
       },
       {
          "id": 595245454,
          "lang": "c",
          "time": "1 hour, 45 minutes",
          "timestamp": 1638331830,
          "status_display": "Accepted",
          "runtime": "0 ms",
          "url": "/submissions/detail/595245454/",
          "is_pending": "Not Pending",
          "title": "Poor Pigs",
          "memory": "5.7 MB",
          "code": "/** https://leetcode.com/problems/poor-pigs/ */\n//There are buckets buckets of liquid, where exactly one of the buckets is poisonous. To figure out which one is poisonous, you feed some number of (poor) pigs the liquid to see whether they will die or not. Unfortunately, you only have minutesToTest minutes to determine which bucket is poisonous.\n//You can feed the pigs according to these steps:\n//Choose some live pigs to feed.\n//For each pig, choose which buckets to feed it. The pig will consume all the chosen buckets simultaneously and will take no time.\n//Wait for minutesToDie minutes. You may not feed any other pigs during this time.\n//After minutesToDie minutes have passed, any pigs that have been fed the poisonous bucket will die, and all others will survive.\n//Repeat this process until you run out of time.\n//Given buckets, minutesToDie, and minutesToTest, return the minimum number of pigs needed to figure out which bucket is poisonous within the allotted time.\n\n\n\nint poorPigs(int buckets, int minutesToDie, int minutesToTest){\n    return (int)ceil(log(buckets)/log(minutesToTest/minutesToDie+1));\n}\n    ",
          "compare_result": "11111111111111111",
          "title_slug": "poor-pigs"
       },
       {
          "id": 595245217,
          "lang": "javascript",
          "time": "1 hour, 46 minutes",
          "timestamp": 1638331797,
          "status_display": "Accepted",
          "runtime": "68 ms",
          "url": "/submissions/detail/595245217/",
          "is_pending": "Not Pending",
          "title": "Pascal's Triangle",
          "memory": "38.7 MB",
          "code": "/** https://leetcode.com/problems/pascals-triangle/ */\n\n/**\n * @param {number} numRows\n * @return {number[][]}\n */\nvar generate = function(numRows) {\n    var result = [];\n    for (var i = 0; i < numRows; i++) {\n        var row = [];\n        for (var j = 0; j <= i; j++) {\n            if (j == 0 || j == i) {\n                row.push(1);\n            } else {\n                row.push(result[i - 1][j - 1] + result[i - 1][j]);\n            }\n        }\n        result.push(row);\n    }\n    return result;   \n};\n    ",
          "compare_result": "11111111111111",
          "title_slug": "pascals-triangle"
       },
       {
          "id": 595245162,
          "lang": "python",
          "time": "1 hour, 46 minutes",
          "timestamp": 1638331788,
          "status_display": "Accepted",
          "runtime": "16 ms",
          "url": "/submissions/detail/595245162/",
          "is_pending": "Not Pending",
          "title": "Pascal's Triangle",
          "memory": "13.3 MB",
          "code": "# https://leetcode.com/problems/pascals-triangle/\n\nclass Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        if numRows == 0:\n            return []\n        if numRows == 1:\n            return [[1]]\n        if numRows == 2:\n            return [[1], [1, 1]]\n        res = [[1], [1, 1]]\n        for i in range(2, numRows):\n            temp = [1]\n            for j in range(1, i):\n                temp.append(res[i-1][j-1] + res[i-1][j])\n            temp.append(1)\n            res.append(temp)\n        return res",
          "compare_result": "11111111111111",
          "title_slug": "pascals-triangle"
       },
       {
          "id": 595245052,
          "lang": "java",
          "time": "1 hour, 46 minutes",
          "timestamp": 1638331774,
          "status_display": "Accepted",
          "runtime": "0 ms",
          "url": "/submissions/detail/595245052/",
          "is_pending": "Not Pending",
          "title": "Pascal's Triangle",
          "memory": "37.3 MB",
          "code": "/** https://leetcode.com/problems/pascals-triangle/ */\n\nclass Solution {\n    public List<List<Integer>> generate(int numRows) {\n        List<List<Integer>> result = new ArrayList<>();\n        if (numRows == 0) return result;\n        result.add(Arrays.asList(1));\n        if (numRows == 1) return result;\n        result.add(Arrays.asList(1, 1));\n        if (numRows == 2) return result;\n        for (int i = 2; i < numRows; i++) {\n            List<Integer> cur = new ArrayList<>();\n            cur.add(1);\n            for (int j = 1; j < i; j++) {\n                cur.add(result.get(i - 1).get(j - 1) + result.get(i - 1).get(j));\n            }\n            cur.add(1);\n            result.add(cur);\n        }\n        return result;\n    }\n}",
          "compare_result": "11111111111111",
          "title_slug": "pascals-triangle"
       },
       {
          "id": 595245001,
          "lang": "c",
          "time": "1 hour, 46 minutes",
          "timestamp": 1638331764,
          "status_display": "Accepted",
          "runtime": "4 ms",
          "url": "/submissions/detail/595245001/",
          "is_pending": "Not Pending",
          "title": "Pascal's Triangle",
          "memory": "5.8 MB",
          "code": "/** https://leetcode.com/problems/pascals-triangle/ */\n\n\n\n/**\n * Return an array of arrays of size *returnSize.\n * The sizes of the arrays are returned as *returnColumnSizes array.\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\n */\nint** generate(int numRows, int* returnSize, int** returnColumnSizes){\n    int** res = (int**)malloc(sizeof(int*) * numRows);\n    *returnColumnSizes = (int*)malloc(sizeof(int) * numRows);\n    *returnSize = numRows;\n    for (int i = 0; i < numRows; i++) {\n        (*returnColumnSizes)[i] = i + 1;\n        res[i] = (int*)malloc(sizeof(int) * (i + 1));\n        res[i][0] = res[i][i] = 1;\n        for (int j = 1; j < i; j++) {\n            res[i][j] = res[i - 1][j - 1] + res[i - 1][j];\n        }\n    }\n    return res;\n}\n    ",
          "compare_result": "11111111111111",
          "title_slug": "pascals-triangle"
       },
       {
          "id": 595244918,
          "lang": "javascript",
          "time": "1 hour, 47 minutes",
          "timestamp": 1638331751,
          "status_display": "Accepted",
          "runtime": "72 ms",
          "url": "/submissions/detail/595244918/",
          "is_pending": "Not Pending",
          "title": "Pascal's Triangle II",
          "memory": "39 MB",
          "code": "/** https://leetcode.com/problems/pascals-triangle-ii/ */\n\n/**\n * @param {number} rowIndex\n * @return {number[]}\n */\nvar getRow = function(rowIndex) {\n    var result = [];\n    for (var i = 0; i <= rowIndex; i++) {\n        result[i] = 1;\n        for (var j = i - 1; j > 0; j--) {\n            result[j] = result[j] + result[j - 1];\n        }\n    }\n    return result;\n};\n    ",
          "compare_result": "1111111111111111111111111111111111",
          "title_slug": "pascals-triangle-ii"
       },
       {
          "id": 595244852,
          "lang": "python",
          "time": "1 hour, 47 minutes",
          "timestamp": 1638331743,
          "status_display": "Accepted",
          "runtime": "12 ms",
          "url": "/submissions/detail/595244852/",
          "is_pending": "Not Pending",
          "title": "Pascal's Triangle II",
          "memory": "13.3 MB",
          "code": "# https://leetcode.com/problems/pascals-triangle-ii/\n\nclass Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        if rowIndex == 0:\n            return [1]\n        elif rowIndex == 1:\n            return [1,1]\n        else:\n            prev = [1,1]\n            for i in range(2,rowIndex+1):\n                curr = [1]\n                for j in range(1,i):\n                    curr.append(prev[j-1]+prev[j])\n                curr.append(1)\n                prev = curr\n            return curr",
          "compare_result": "1111111111111111111111111111111111",
          "title_slug": "pascals-triangle-ii"
       },
       {
          "id": 595244806,
          "lang": "java",
          "time": "1 hour, 47 minutes",
          "timestamp": 1638331735,
          "status_display": "Accepted",
          "runtime": "1 ms",
          "url": "/submissions/detail/595244806/",
          "is_pending": "Not Pending",
          "title": "Pascal's Triangle II",
          "memory": "36.7 MB",
          "code": "/** https://leetcode.com/problems/pascals-triangle-ii/ */\n\nclass Solution {\n    public List<Integer> getRow(int rowIndex) {\n        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i <= rowIndex; i++) {\n            result.add(0, 1);\n            for (int j = 1; j < result.size() - 1; j++) {\n                result.set(j, result.get(j) + result.get(j + 1));\n            }\n        }\n        return result;\n    }\n}\n    ",
          "compare_result": "1111111111111111111111111111111111",
          "title_slug": "pascals-triangle-ii"
       },
       {
          "id": 595244744,
          "lang": "c",
          "time": "1 hour, 47 minutes",
          "timestamp": 1638331727,
          "status_display": "Accepted",
          "runtime": "0 ms",
          "url": "/submissions/detail/595244744/",
          "is_pending": "Not Pending",
          "title": "Pascal's Triangle II",
          "memory": "5.7 MB",
          "code": "/** https://leetcode.com/problems/pascals-triangle-ii/ */\n\n\n\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* getRow(int rowIndex, int* returnSize){\n    int* res = (int*)malloc(sizeof(int) * (rowIndex + 1));\n    *returnSize = rowIndex + 1;\n    res[0] = 1;\n    for (int i = 1; i <= rowIndex; i++) {\n        res[i] = 1;\n        for (int j = i - 1; j > 0; j--) {\n            res[j] += res[j - 1];\n        }\n    }\n    return res;\n}\n    ",
          "compare_result": "1111111111111111111111111111111111",
          "title_slug": "pascals-triangle-ii"
       },
       {
          "id": 595244639,
          "lang": "javascript",
          "time": "1 hour, 47 minutes",
          "timestamp": 1638331712,
          "status_display": "Runtime Error",
          "runtime": "N/A",
          "url": "/submissions/detail/595244639/",
          "is_pending": "Not Pending",
          "title": "Partition Equal Subset Sum",
          "memory": "N/A",
          "code": "/** https://leetcode.com/problems/partition-equal-subset-sum/ */\n//Given a non-empty array nums containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.\n\n/**\n * @param {number[]} nums\n * @return {boolean}\n */\n var canPartition = function(nums) {\n    var sum = 0;\nfor (var i = 0; i < nums.length; i++) {\n   sum += nums[i];\n}\nif (sum % 2 != 0) {\n   return false;\n}\nvar target = sum / 2;\nvar dp = [];\nfor (var i = 0; i < nums.length; i++) {\n   dp[i] = [];\n   for (var j = 0; j <= target; j++) {\n       dp[i][j] = false;\n   }\n}\nfor (var i = 0; i < nums.length; i++) {\n   dp[i][0] = true;\n}\nfor (var i = 0; i < nums.length; i++) {\n   for (var j = 1; j <= target; j++) {\n       if (j - nums[i] >= 0) {\n           dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]];\n       } else {\n           dp[i][j] = dp[i - 1][j];\n       }\n   }\n}\nreturn dp[nums.length - 1][target];\n};\n",
          "compare_result": "00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
          "title_slug": "partition-equal-subset-sum"
       },
       {
          "id": 595244568,
          "lang": "python",
          "time": "1 hour, 47 minutes",
          "timestamp": 1638331702,
          "status_display": "Wrong Answer",
          "runtime": "N/A",
          "url": "/submissions/detail/595244568/",
          "is_pending": "Not Pending",
          "title": "Partition Equal Subset Sum",
          "memory": "N/A",
          "code": "# https://leetcode.com/problems/partition-equal-subset-sum/\n#Given a non-empty array nums containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.\n\nclass Solution(object):\n    def canPartition(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        n = len(nums)\n        if n == 0:\n            return False\n        if n == 1:\n            return True\n        sum_nums = sum(nums)\n        if sum_nums % 2 != 0:\n            return False\n\n        target = sum_nums / 2\n        dp = [False] * (target + 1)\n        dp[0] = True\n        for i in range(n):\n            for j in range(target, nums[i]-1, -1):\n                dp[j] = dp[j] | dp[j - nums[i]]\n        return dp[target]    \n    ",
          "compare_result": "11101111111111111111111110111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
          "title_slug": "partition-equal-subset-sum"
       },
       {
          "id": 595244494,
          "lang": "java",
          "time": "1 hour, 47 minutes",
          "timestamp": 1638331694,
          "status_display": "Accepted",
          "runtime": "17 ms",
          "url": "/submissions/detail/595244494/",
          "is_pending": "Not Pending",
          "title": "Partition Equal Subset Sum",
          "memory": "38.3 MB",
          "code": "/** https://leetcode.com/problems/partition-equal-subset-sum/ */\n//Given a non-empty array nums containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.\n\nclass Solution {\n    public boolean canPartition(int[] nums) {\n        int sum = 0;\n        for (int num : nums) {\n            sum += num;\n        }\n        if (sum % 2 != 0) {\n            return false;\n        }\n        sum /= 2;\n        boolean[] dp = new boolean[sum + 1];\n        dp[0] = true;\n        for (int num : nums) {\n            for (int i = sum; i >= num; i--) {\n                dp[i] = dp[i] || dp[i - num];\n            }\n        }\n        return dp[sum];\n    }\n}",
          "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
          "title_slug": "partition-equal-subset-sum"
       },
       {
          "id": 595244446,
          "lang": "c",
          "time": "1 hour, 48 minutes",
          "timestamp": 1638331688,
          "status_display": "Accepted",
          "runtime": "68 ms",
          "url": "/submissions/detail/595244446/",
          "is_pending": "Not Pending",
          "title": "Partition Equal Subset Sum",
          "memory": "8.1 MB",
          "code": "/** https://leetcode.com/problems/partition-equal-subset-sum/ */\n//Given a non-empty array nums containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.\n\n\n\nbool canPartition(int* nums, int numsSize){\n    int sum = 0;\n    for (int i = 0; i < numsSize; i++) {\n        sum += nums[i];\n    }\n    if (sum % 2 != 0) {\n        return false;\n    }\n    int target = sum / 2;\n    bool dp[numsSize][target + 1];\n    memset(dp, 0, sizeof(dp));\n    for (int i = 0; i < numsSize; i++) {\n        dp[i][0] = true;\n    }\n    for (int i = 1; i <= target; i++) {\n        dp[0][i] = (nums[0] == i);\n    }\n    for (int i = 1; i < numsSize; i++) {\n        for (int j = 1; j <= target; j++) {\n            dp[i][j] = dp[i - 1][j];\n            if (j >= nums[i]) {\n                dp[i][j] = dp[i][j] || dp[i - 1][j - nums[i]];\n            }\n        }\n    }\n    return dp[numsSize - 1][target];\n}\n    ",
          "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
          "title_slug": "partition-equal-subset-sum"
       },
       {
          "id": 595244334,
          "lang": "javascript",
          "time": "1 hour, 48 minutes",
          "timestamp": 1638331673,
          "status_display": "Wrong Answer",
          "runtime": "N/A",
          "url": "/submissions/detail/595244334/",
          "is_pending": "Not Pending",
          "title": "Non-overlapping Intervals",
          "memory": "N/A",
          "code": "/** https://leetcode.com/problems/non-overlapping-intervals/ */\n//Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.\n\n/**\n * @param {number[][]} intervals\n * @return {number}\n */\n var eraseOverlapIntervals = function(intervals) {\n         if (intervals.length === 0) return 0;\n    intervals.sort((a, b) => a[0] - b[0]);\n    let count = 0;\n    let end = intervals[0][1];\n    for (let i = 1; i < intervals.length; i++) {\n        if (intervals[i][0] >= end) {\n            end = intervals[i][1];\n        } else {\n            count++;\n        }\n    }\n    return count;\n};\n    ",
          "compare_result": "1111101111111100000000000000000000000000000000000000100000",
          "title_slug": "non-overlapping-intervals"
       },
       {
          "id": 595244266,
          "lang": "python",
          "time": "1 hour, 48 minutes",
          "timestamp": 1638331664,
          "status_display": "Accepted",
          "runtime": "1252 ms",
          "url": "/submissions/detail/595244266/",
          "is_pending": "Not Pending",
          "title": "Non-overlapping Intervals",
          "memory": "59.9 MB",
          "code": "# https://leetcode.com/problems/non-overlapping-intervals/\n#Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.\n\nclass Solution(object):\n    def eraseOverlapIntervals(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not intervals:\n            return 0\n        intervals.sort(key=lambda x: x[1])\n        end = intervals[0][1]\n        count = 0\n        for i in range(1, len(intervals)):\n            if intervals[i][0] >= end:\n                end = intervals[i][1]\n            else:\n                count += 1\n        return count",
          "compare_result": "1111111111111111111111111111111111111111111111111111111111",
          "title_slug": "non-overlapping-intervals"
       },
       {
          "id": 595244188,
          "lang": "java",
          "time": "1 hour, 48 minutes",
          "timestamp": 1638331654,
          "status_display": "Accepted",
          "runtime": "47 ms",
          "url": "/submissions/detail/595244188/",
          "is_pending": "Not Pending",
          "title": "Non-overlapping Intervals",
          "memory": "96.3 MB",
          "code": "/** https://leetcode.com/problems/non-overlapping-intervals/ */\n//Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.\n\nclass Solution {\n    public int eraseOverlapIntervals(int[][] intervals) {\n        if (intervals == null || intervals.length == 0) {\n            return 0;\n        }\n        Arrays.sort(intervals, (a, b) -> a[0] - b[0]);\n        int count = 0;\n        int end = intervals[0][1];\n        for (int i = 1; i < intervals.length; i++) {\n            if (intervals[i][0] < end) {\n                count++;\n                end = Math.min(end, intervals[i][1]);\n            } else {\n                end = intervals[i][1];\n            }\n        }\n        return count;\n    }\n}",
          "compare_result": "1111111111111111111111111111111111111111111111111111111111",
          "title_slug": "non-overlapping-intervals"
       },
       {
          "id": 595244114,
          "lang": "c",
          "time": "1 hour, 48 minutes",
          "timestamp": 1638331641,
          "status_display": "Wrong Answer",
          "runtime": "N/A",
          "url": "/submissions/detail/595244114/",
          "is_pending": "Not Pending",
          "title": "Non-overlapping Intervals",
          "memory": "N/A",
          "code": "/** https://leetcode.com/problems/non-overlapping-intervals/ */\n//Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.\n\n\nint compare(const void *a, const void *b){\n    return *(int *)a - *(int *)b;\n}\n    \n\nint eraseOverlapIntervals(int** intervals, int intervalsSize, int* intervalsColSize){\n    int i,j;\n    int count = 0;\n    int *starts = malloc(sizeof(int)*intervalsSize);\n    int *ends = malloc(sizeof(int)*intervalsSize);\n    for(i=0;i<intervalsSize;i++){\n        starts[i] = intervals[i][0];\n        ends[i] = intervals[i][1];\n    }\n    qsort(starts,intervalsSize,sizeof(int),compare);\n    qsort(ends,intervalsSize,sizeof(int),compare);\n    for(i=0;i<intervalsSize-1;i++){\n        if(ends[i]>starts[i+1]){\n            count++;\n        }\n    }\n    free(starts);\n    free(ends);\n    return count;\n}\n",
          "compare_result": "0111101111110000000000000000000000000000000000000000000000",
          "title_slug": "non-overlapping-intervals"
       },
       {
          "id": 595243908,
          "lang": "javascript",
          "time": "1 hour, 49 minutes",
          "timestamp": 1638331611,
          "status_display": "Runtime Error",
          "runtime": "N/A",
          "url": "/submissions/detail/595243908/",
          "is_pending": "Not Pending",
          "title": "Longest Increasing Subsequence",
          "memory": "N/A",
          "code": "/** https://leetcode.com/problems/longest-increasing-subsequence/ */\n//Given an integer array nums, return the length of the longest strictly increasing subsequence.\n//A subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, [3,6,2,7] is a subsequence of the array [0,3,1,6,2,2,7].\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\n var lengthOfLIS = function(nums) {\n    if(!nums || nums.length === 0) return 0;\n    let dp = [nums[0]];\n    for(let i = 1; i < nums.length; i++){\n        if(nums[i] > dp[dp.length - 1]){\n            dp.push(nums[i]);\n        }else{\n            let index = binarySearch(dp, nums[i]);\n            dp[index] = nums[i];\n        }\n    }\n    return dp.length;\n};\n    ",
          "compare_result": "000000000000000000000000000000000000000000000000000000",
          "title_slug": "longest-increasing-subsequence"
       }
    ],
    "has_next": true,
    "last_key": "%7B%22pk%22%3A%20%7B%22N%22%3A%20%22595243908%22%7D%2C%20%22dt%22%3A%20%7B%22S%22%3A%20%222021-12-01T04%3A06%3A51.460345%2B0000%22%7D%2C%20%22sid%22%3A%20%7B%22N%22%3A%20%225508277%22%7D%7D"
 }