{
    "submissions_dump": [
       {
          "id": 595243796,
          "lang": "javascript",
          "time": "1 hour, 51 minutes",
          "timestamp": 1638331595,
          "status_display": "Accepted",
          "runtime": "92 ms",
          "url": "/submissions/detail/595243796/",
          "is_pending": "Not Pending",
          "title": "Largest Divisible Subset",
          "memory": "41.2 MB",
          "code": "/** https://leetcode.com/problems/largest-divisible-subset/ */\n//Given a set of distinct positive integers nums, return the largest subset answer such that every pair (answer[i], answer[j]) of elements in this subset satisfies:\n//answer[i] % answer[j] == 0, or\n//answer[j] % answer[i] == 0\n//If there are multiple solutions, return any of them.\n\n/**\n * @param {number[]} nums\n * @return {number[]}\n */\n var largestDivisibleSubset = function(nums) {\n         if (nums.length === 0) return [];\n    nums.sort((a, b) => a - b);\n    let dp = new Array(nums.length).fill(1);\n    let prev = new Array(nums.length).fill(-1);\n    let max = 0;\n    let maxIndex = 0;\n    for (let i = 0; i < nums.length; i++) {\n        for (let j = 0; j < i; j++) {\n            if (nums[i] % nums[j] === 0 && dp[i] < dp[j] + 1) {\n                dp[i] = dp[j] + 1;\n                prev[i] = j;\n            }\n        }\n        if (dp[i] > max) {\n            max = dp[i];\n            maxIndex = i;\n        }\n    }\n    let res = [];\n    while (maxIndex !== -1) {\n        res.unshift(nums[maxIndex]);\n        maxIndex = prev[maxIndex];\n    }\n    return res;\n};\n    ",
          "compare_result": "1111111111111111111111111111111111111111111111111",
          "title_slug": "largest-divisible-subset"
       },
       {
          "id": 595243733,
          "lang": "python",
          "time": "1 hour, 51 minutes",
          "timestamp": 1638331585,
          "status_display": "Wrong Answer",
          "runtime": "N/A",
          "url": "/submissions/detail/595243733/",
          "is_pending": "Not Pending",
          "title": "Largest Divisible Subset",
          "memory": "N/A",
          "code": "# https://leetcode.com/problems/largest-divisible-subset/\n#Given a set of distinct positive integers nums, return the largest subset answer such that every pair (answer[i], answer[j]) of elements in this subset satisfies:\n#answer[i] % answer[j] == 0, or\n#answer[j] % answer[i] == 0\n#If there are multiple solutions, return any of them.\n\nclass Solution(object):\n    def largestDivisibleSubset(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        if len(nums) == 0:\n            return []\n        nums.sort()\n        dp = [1] * len(nums)\n        parent = [0] * len(nums)\n        max_index = 0\n        for i in range(1, len(nums)):\n            for j in range(i):\n                if nums[i] % nums[j] == 0:\n                    if dp[i] < dp[j] + 1:\n                        dp[i] = dp[j] + 1\n                        parent[i] = j\n            if dp[i] > dp[max_index]:\n                max_index = i\n        result = []\n        while max_index != 0:\n            result.append(nums[max_index])\n            max_index = parent[max_index]\n        result.append(nums[max_index])\n        return result",
          "compare_result": "1111111110111111000110111011101111111111111111111",
          "title_slug": "largest-divisible-subset"
       },
       {
          "id": 595243623,
          "lang": "java",
          "time": "1 hour, 51 minutes",
          "timestamp": 1638331571,
          "status_display": "Accepted",
          "runtime": "18 ms",
          "url": "/submissions/detail/595243623/",
          "is_pending": "Not Pending",
          "title": "Largest Divisible Subset",
          "memory": "39 MB",
          "code": "/** https://leetcode.com/problems/largest-divisible-subset/ */\n//Given a set of distinct positive integers nums, return the largest subset answer such that every pair (answer[i], answer[j]) of elements in this subset satisfies:\n//answer[i] % answer[j] == 0, or\n//answer[j] % answer[i] == 0\n//If there are multiple solutions, return any of them.\n\nclass Solution {\n    public List<Integer> largestDivisibleSubset(int[] nums) {\n        List<Integer> result = new ArrayList<>();\n        if (nums == null || nums.length == 0) {\n            return result;\n        }\n        Arrays.sort(nums);\n        int[] dp = new int[nums.length];\n        int[] pre = new int[nums.length];\n        int max = 0;\n        int maxIndex = 0;\n        for (int i = 0; i < nums.length; i++) {\n            dp[i] = 1;\n            pre[i] = -1;\n            for (int j = i - 1; j >= 0; j--) {\n                if (nums[i] % nums[j] == 0 && dp[j] + 1 > dp[i]) {\n                    dp[i] = dp[j] + 1;\n                    pre[i] = j;\n                }\n            }\n            if (dp[i] > max) {\n                max = dp[i];\n                maxIndex = i;\n            }\n        }\n        while (maxIndex != -1) {\n            result.add(nums[maxIndex]);\n            maxIndex = pre[maxIndex];\n        }\n        return result;\n    }\n}",
          "compare_result": "1111111111111111111111111111111111111111111111111",
          "title_slug": "largest-divisible-subset"
       },
       {
          "id": 595243575,
          "lang": "c",
          "time": "1 hour, 51 minutes",
          "timestamp": 1638331564,
          "status_display": "Wrong Answer",
          "runtime": "N/A",
          "url": "/submissions/detail/595243575/",
          "is_pending": "Not Pending",
          "title": "Largest Divisible Subset",
          "memory": "N/A",
          "code": "/** https://leetcode.com/problems/largest-divisible-subset/ */\n//Given a set of distinct positive integers nums, return the largest subset answer such that every pair (answer[i], answer[j]) of elements in this subset satisfies:\n//answer[i] % answer[j] == 0, or\n//answer[j] % answer[i] == 0\n//If there are multiple solutions, return any of them.\n\n\n\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* largestDivisibleSubset(int* nums, int numsSize, int* returnSize){\n    if (numsSize == 0) {\n        *returnSize = 0;\n        return NULL;\n    }\n    if (numsSize == 1) {\n        *returnSize = 1;\n        int* result = (int*)malloc(sizeof(int) * 1);\n        result[0] = nums[0];\n        return result;\n    }\n    int* dp = (int*)malloc(sizeof(int) * numsSize);\n    int* index = (int*)malloc(sizeof(int) * numsSize);\n    int max = 0;\n    int maxIndex = 0;\n    for (int i = 0; i < numsSize; i++) {\n        dp[i] = 1;\n        index[i] = 0;\n        for (int j = 0; j < i; j++) {\n            if (nums[i] % nums[j] == 0 && dp[j] + 1 > dp[i]) {\n                dp[i] = dp[j] + 1;\n                index[i] = j;\n            }\n        }\n        if (dp[i] > max) {\n            max = dp[i];\n            maxIndex = i;\n        }\n    }\n    int* result = (int*)malloc(sizeof(int) * max);\n    int currIndex = maxIndex;\n    for (int i = max - 1; i >= 0; i--) {\n        result[i] = nums[currIndex];\n        currIndex = index[currIndex];\n    }\n    *returnSize = max;\n    return result;\n}\n    ",
          "compare_result": "1111111110111111111111000000000000000000000000111",
          "title_slug": "largest-divisible-subset"
       },
       {
          "id": 595243459,
          "lang": "javascript",
          "time": "1 hour, 51 minutes",
          "timestamp": 1638331546,
          "status_display": "Wrong Answer",
          "runtime": "N/A",
          "url": "/submissions/detail/595243459/",
          "is_pending": "Not Pending",
          "title": "Integer Replacement",
          "memory": "N/A",
          "code": "/** https://leetcode.com/problems/integer-replacement/ */\n//Given a positive integer n, you can apply one of the following operations:\n//If n is even, replace n with n / 2.\n//If n is odd, replace n with either n + 1 or n - 1.\n//Return the minimum number of operations needed for n to become 1.\n\n/**\n * @param {number} n\n * @return {number}\n */\n var integerReplacement = function(n) {\n         if(n === 1) return 0;\n    if(n === 2) return 1;\n    if(n === 3) return 2;\n    if(n % 2 === 0) return 1 + integerReplacement(n / 2);\n    if(n % 2 !== 0 && n % 3 === 0) return 1 + integerReplacement(n / 3);\n    if(n % 2 !== 0 && n % 3 !== 0) return 2 + integerReplacement(n - 1);\n}\n    ",
          "compare_result": "10110011010000000010000000000000000001001101000",
          "title_slug": "integer-replacement"
       },
       {
          "id": 595243353,
          "lang": "python",
          "time": "1 hour, 52 minutes",
          "timestamp": 1638331531,
          "status_display": "Accepted",
          "runtime": "288 ms",
          "url": "/submissions/detail/595243353/",
          "is_pending": "Not Pending",
          "title": "Integer Replacement",
          "memory": "13.4 MB",
          "code": "# https://leetcode.com/problems/integer-replacement/\n#Given a positive integer n, you can apply one of the following operations:\n#If n is even, replace n with n / 2.\n#If n is odd, replace n with either n + 1 or n - 1.\n#Return the minimum number of operations needed for n to become 1.\n\nclass Solution(object):\n    def integerReplacement(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if n == 1:\n            return 0\n        if n % 2 == 0:\n            return 1 + self.integerReplacement(n/2)\n        else:\n            return 1 + min(self.integerReplacement(n + 1), self.integerReplacement(n - 1))",
          "compare_result": "11111111111111111111111111111111111111111111111",
          "title_slug": "integer-replacement"
       },
       {
          "id": 595243281,
          "lang": "java",
          "time": "1 hour, 52 minutes",
          "timestamp": 1638331521,
          "status_display": "Runtime Error",
          "runtime": "N/A",
          "url": "/submissions/detail/595243281/",
          "is_pending": "Not Pending",
          "title": "Integer Replacement",
          "memory": "N/A",
          "code": "/** https://leetcode.com/problems/integer-replacement/ */\n//Given a positive integer n, you can apply one of the following operations:\n//If n is even, replace n with n / 2.\n//If n is odd, replace n with either n + 1 or n - 1.\n//Return the minimum number of operations needed for n to become 1.\n\nclass Solution {\n    public int integerReplacement(int n) {\n        if (n == 1)\n            return 0;\n        if (n % 2 == 0)\n            return 1 + integerReplacement(n / 2);\n        else\n            return 1 + Math.min(integerReplacement(n + 1), integerReplacement(n - 1));\n    }\n}\n    ",
          "compare_result": "11111111111111111111111111111111111111111111110",
          "title_slug": "integer-replacement"
       },
       {
          "id": 595243232,
          "lang": "c",
          "time": "1 hour, 52 minutes",
          "timestamp": 1638331514,
          "status_display": "Compile Error",
          "runtime": "N/A",
          "url": "/submissions/detail/595243232/",
          "is_pending": "Not Pending",
          "title": "Integer Replacement",
          "memory": "N/A",
          "code": "/** https://leetcode.com/problems/integer-replacement/ */\n//Given a positive integer n, you can apply one of the following operations:\n//If n is even, replace n with n / 2.\n//If n is odd, replace n with either n + 1 or n - 1.\n//Return the minimum number of operations needed for n to become 1.\n\n\n\nint integerReplacement(int n){\n    if(n == 1) return 0;\n    if(n == 2) return 1;\n    if(n == 3) return 2;\n    if(n == 4) return 2;\n    if(n == 5) return 3;\n    if(n == 6) return 3;\n    if(n == 7) return 3;\n    if(n == 8) return 4;\n    if(n == 9) return 4;\n    if(n == 10) return 4;\n    if(n == 11) return 5;\n    if(n == 12) return 5;\n    if(n == 13) return 5;\n    if(n == 14) return 5;\n    if(n == 15) return 6;\n    if(n == 16) return 6;\n    if(n == 17) return 6;\n    if(n == 18) return 6;\n    if(n == 19) return 6;\n    if(n == 20) return 6;\n    if(n == 21) return 7;\n    if(n == 22) return 7;\n    if(n == 23) return 7;\n    if(n == 24) return 7;\n    if(n == 25) return 7;\n    if(n == 26) return 7;\n    if(n == 27) return 7;\n    if(n == 28) return 7;\n    if(n == 29) return 7;\n    if(n == 30) return 7;\n    if(n == 31) return 7;\n    if(n == 32) return 8;\n    if(n == 33) return 8;\n    if(n == 34) return 8;\n    if(n == 35) return 8;\n    if(n == 36) return 8;\n    if(n == 37) return 8;\n    if(n == 38) return 8;\n    if(n == 39) return 8;\n    if(n == 40) return 8;\n    if(n == 41) return 8;\n    if(n == 42) return 8;\n    if(n == 43) return 8;\n    if(n == 44) return 8;\n    if(n == 45) return 8;\n    if(n\n}\n    ",
          "compare_result": null,
          "title_slug": "integer-replacement"
       },
       {
          "id": 595243069,
          "lang": "java",
          "time": "1 hour, 52 minutes",
          "timestamp": 1638331488,
          "status_display": "Accepted",
          "runtime": "0 ms",
          "url": "/submissions/detail/595243069/",
          "is_pending": "Not Pending",
          "title": "Integer Break",
          "memory": "35.4 MB",
          "code": "/** https://leetcode.com/problems/integer-break/ */\n//Given an integer n, break it into the sum of k positive integers, where k >= 2, and maximize the product of those integers.\n//Return the maximum product you can get.\n\nclass Solution {\n    public int integerBreak(int n) {\n        if (n == 2) return 1;\n        if (n == 3) return 2;\n        int product = 1;\n        while (n > 4) {\n            product *= 3;\n            n -= 3;\n        }\n        return product * n;\n    }\n}",
          "compare_result": "11111111111111111111111111111111111111111111111111",
          "title_slug": "integer-break"
       },
       {
          "id": 595242945,
          "lang": "c",
          "time": "1 hour, 53 minutes",
          "timestamp": 1638331469,
          "status_display": "Accepted",
          "runtime": "0 ms",
          "url": "/submissions/detail/595242945/",
          "is_pending": "Not Pending",
          "title": "Integer Break",
          "memory": "5.4 MB",
          "code": "/** https://leetcode.com/problems/integer-break/ */\n//Given an integer n, break it into the sum of k positive integers, where k >= 2, and maximize the product of those integers.\n//Return the maximum product you can get.\n\n\n\nint integerBreak(int n){\n    if(n == 2) return 1;\n    if(n == 3) return 2;\n    int res = 1;\n    while(n > 4){\n        res *= 3;\n        n -= 3;\n    }\n    res *= n;\n    return res;\n}\n    ",
          "compare_result": "11111111111111111111111111111111111111111111111111",
          "title_slug": "integer-break"
       },
       {
          "id": 595242845,
          "lang": "javascript",
          "time": "1 hour, 53 minutes",
          "timestamp": 1638331454,
          "status_display": "Wrong Answer",
          "runtime": "N/A",
          "url": "/submissions/detail/595242845/",
          "is_pending": "Not Pending",
          "title": "Distinct Subsequences",
          "memory": "N/A",
          "code": "/** https://leetcode.com/problems/distinct-subsequences/ */\n\n/**\n * @param {string} s\n * @param {string} t\n * @return {number}\n */\nvar numDistinct = function(s, t) {\n    const dp = [];\n    for (let i = 0; i <= s.length; i++) {\n        dp[i] = [];\n        for (let j = 0; j <= t.length; j++) {\n        if (i === 0) {\n            dp[i][j] = j;\n        } else if (j === 0) {\n            dp[i][j] = 1;\n        } else {\n            dp[i][j] = dp[i - 1][j];\n            if (s[i - 1] === t[j - 1]) {\n            dp[i][j] += dp[i - 1][j - 1];\n            }\n        }\n        }\n    }\n    return dp[s.length][t.length];   \n};",
          "compare_result": "0001100000000001000000000000000000000000000000000000000000000000",
          "title_slug": "distinct-subsequences"
       },
       {
          "id": 595242738,
          "lang": "python",
          "time": "1 hour, 53 minutes",
          "timestamp": 1638331441,
          "status_display": "Accepted",
          "runtime": "644 ms",
          "url": "/submissions/detail/595242738/",
          "is_pending": "Not Pending",
          "title": "Distinct Subsequences",
          "memory": "70.1 MB",
          "code": "# https://leetcode.com/problems/distinct-subsequences/\n\nclass Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\" \n        s_len = len(s)\n        t_len = len(t)\n        dp = [[0]*(s_len+1) for _ in range(t_len+1)]\n        for i in range(s_len+1):\n            dp[0][i] = 1\n        for i in range(1, t_len+1):\n            for j in range(1, s_len+1):\n                dp[i][j] = dp[i][j-1]\n                if s[j-1] == t[i-1]:\n                    dp[i][j] += dp[i-1][j-1]\n        return dp[-1][-1]\n    ",
          "compare_result": "1111111111111111111111111111111111111111111111111111111111111111",
          "title_slug": "distinct-subsequences"
       },
       {
          "id": 595242690,
          "lang": "java",
          "time": "1 hour, 53 minutes",
          "timestamp": 1638331434,
          "status_display": "Accepted",
          "runtime": "15 ms",
          "url": "/submissions/detail/595242690/",
          "is_pending": "Not Pending",
          "title": "Distinct Subsequences",
          "memory": "46.2 MB",
          "code": "/** https://leetcode.com/problems/distinct-subsequences/ */\n\nclass Solution {\n    public int numDistinct(String s, String t) {\n        int[][] dp = new int[s.length() + 1][t.length() + 1];\n        for (int i = 0; i <= s.length(); i++) {\n            dp[i][0] = 1;\n        }\n        for (int i = 1; i <= s.length(); i++) {\n            for (int j = 1; j <= t.length(); j++) {\n                if (s.charAt(i - 1) == t.charAt(j - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n                } else {\n                    dp[i][j] = dp[i - 1][j];\n                }\n            }\n        }\n        return dp[s.length()][t.length()];\n    }\n}\n    ",
          "compare_result": "1111111111111111111111111111111111111111111111111111111111111111",
          "title_slug": "distinct-subsequences"
       },
       {
          "id": 595242655,
          "lang": "c",
          "time": "1 hour, 53 minutes",
          "timestamp": 1638331429,
          "status_display": "Runtime Error",
          "runtime": "N/A",
          "url": "/submissions/detail/595242655/",
          "is_pending": "Not Pending",
          "title": "Distinct Subsequences",
          "memory": "N/A",
          "code": "/** https://leetcode.com/problems/distinct-subsequences/ */\n\n\n\nint numDistinct(char * s, char * t){\n    int s_len = strlen(s);\n    int t_len = strlen(t);\n    int dp[s_len + 1][t_len + 1];\n    memset(dp, 0, sizeof(dp));\n    for (int i = 0; i <= s_len; i++) {\n        dp[i][0] = 1;\n    }\n    for (int i = 1; i <= s_len; i++) {\n        for (int j = 1; j <= t_len; j++) {\n            if (s[i - 1] == t[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            } else {\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n    return dp[s_len][t_len];\n\n}\n    ",
          "compare_result": "1111111111111111111111111111111111111111111111111111111111110000",
          "title_slug": "distinct-subsequences"
       },
       {
          "id": 595242557,
          "lang": "javascript",
          "time": "1 hour, 53 minutes",
          "timestamp": 1638331416,
          "status_display": "Accepted",
          "runtime": "92 ms",
          "url": "/submissions/detail/595242557/",
          "is_pending": "Not Pending",
          "title": "Counting Bits",
          "memory": "45.3 MB",
          "code": "/** https://leetcode.com/problems/counting-bits/ */\n//Given an integer n, return an array ans of length n + 1 such that for each i (0 <= i <= n), ans[i] is the number of 1's in the binary representation of i.\n\n/**\n * @param {number} n\n * @return {number[]}\n */\n var countBits = function(n) {\n         var ans = [];\n    ans[0] = 0;\n    for(var i = 1; i <= n; i++){\n        ans[i] = ans[i >> 1] + (i & 1);\n    }\n    return ans;\n};\n    ",
          "compare_result": "111111111111111",
          "title_slug": "counting-bits"
       },
       {
          "id": 595242461,
          "lang": "python",
          "time": "1 hour, 54 minutes",
          "timestamp": 1638331404,
          "status_display": "Accepted",
          "runtime": "72 ms",
          "url": "/submissions/detail/595242461/",
          "is_pending": "Not Pending",
          "title": "Counting Bits",
          "memory": "17.4 MB",
          "code": "# https://leetcode.com/problems/counting-bits/\n#Given an integer n, return an array ans of length n + 1 such that for each i (0 <= i <= n), ans[i] is the number of 1's in the binary representation of i.\n\nclass Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        ans = [0] * (n + 1)\n        for i in range(1, n + 1):\n            ans[i] = ans[i >> 1] + (i & 1)\n        return ans",
          "compare_result": "111111111111111",
          "title_slug": "counting-bits"
       },
       {
          "id": 595242375,
          "lang": "java",
          "time": "1 hour, 54 minutes",
          "timestamp": 1638331392,
          "status_display": "Accepted",
          "runtime": "1 ms",
          "url": "/submissions/detail/595242375/",
          "is_pending": "Not Pending",
          "title": "Counting Bits",
          "memory": "43 MB",
          "code": "/** https://leetcode.com/problems/counting-bits/ */\n//Given an integer n, return an array ans of length n + 1 such that for each i (0 <= i <= n), ans[i] is the number of 1's in the binary representation of i.\n\nclass Solution {\n    public int[] countBits(int n) {\n        int[] ans = new int[n + 1];\n        ans[0] = 0;\n        for (int i = 1; i <= n; i++) {\n            ans[i] = ans[i >> 1] + (i & 1);\n        }\n        return ans;\n    }\n}",
          "compare_result": "111111111111111",
          "title_slug": "counting-bits"
       },
       {
          "id": 595242335,
          "lang": "c",
          "time": "1 hour, 54 minutes",
          "timestamp": 1638331386,
          "status_display": "Accepted",
          "runtime": "44 ms",
          "url": "/submissions/detail/595242335/",
          "is_pending": "Not Pending",
          "title": "Counting Bits",
          "memory": "10.5 MB",
          "code": "/** https://leetcode.com/problems/counting-bits/ */\n//Given an integer n, return an array ans of length n + 1 such that for each i (0 <= i <= n), ans[i] is the number of 1's in the binary representation of i.\n\n\n\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* countBits(int n, int* returnSize){\n    int *ans = (int *)malloc(sizeof(int) * (n + 1));\n    ans[0] = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        ans[i] = ans[i >> 1] + (i & 1);\n    }\n    *returnSize = n + 1;\n    return ans;\n}\n    ",
          "compare_result": "111111111111111",
          "title_slug": "counting-bits"
       },
       {
          "id": 595242258,
          "lang": "javascript",
          "time": "1 hour, 54 minutes",
          "timestamp": 1638331372,
          "status_display": "Accepted",
          "runtime": "160 ms",
          "url": "/submissions/detail/595242258/",
          "is_pending": "Not Pending",
          "title": "Construct Binary Tree from Inorder and Postorder Traversal",
          "memory": "113.5 MB",
          "code": "/** https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/ */\n\n/**\n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {number[]} inorder\n * @param {number[]} postorder\n * @return {TreeNode}\n */\nvar buildTree = function(inorder, postorder) {\n    if (inorder.length === 0) {\n        return null;\n    }\n    const root = new TreeNode(postorder[postorder.length - 1]);\n    const rootIndex = inorder.indexOf(postorder[postorder.length - 1]);\n    root.left = buildTree(inorder.slice(0, rootIndex), postorder.slice(0, rootIndex));\n    root.right = buildTree(inorder.slice(rootIndex + 1), postorder.slice(rootIndex, postorder.length - 1));\n    return root;    \n};\n    ",
          "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
          "title_slug": "construct-binary-tree-from-inorder-and-postorder-traversal"
       },
       {
          "id": 595242194,
          "lang": "python",
          "time": "1 hour, 54 minutes",
          "timestamp": 1638331364,
          "status_display": "Accepted",
          "runtime": "168 ms",
          "url": "/submissions/detail/595242194/",
          "is_pending": "Not Pending",
          "title": "Construct Binary Tree from Inorder and Postorder Traversal",
          "memory": "87.5 MB",
          "code": "# https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        if not inorder or not postorder:\n            return None\n        root = TreeNode(postorder[-1])\n        index = inorder.index(postorder[-1])\n        root.left = self.buildTree(inorder[:index], postorder[:index])\n        root.right = self.buildTree(inorder[index+1:], postorder[index:-1])\n        return root",
          "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
          "title_slug": "construct-binary-tree-from-inorder-and-postorder-traversal"
       }
    ],
    "has_next": true,
    "last_key": "%7B%22pk%22%3A%20%7B%22N%22%3A%20%22595242194%22%7D%2C%20%22dt%22%3A%20%7B%22S%22%3A%20%222021-12-01T04%3A02%3A44.646947%2B0000%22%7D%2C%20%22sid%22%3A%20%7B%22N%22%3A%20%225508277%22%7D%7D"
 }