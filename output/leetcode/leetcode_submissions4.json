{
    "submissions_dump": [
       {
          "id": 595242116,
          "lang": "java",
          "time": "1 hour, 56 minutes",
          "timestamp": 1638331351,
          "status_display": "Accepted",
          "runtime": "3 ms",
          "url": "/submissions/detail/595242116/",
          "is_pending": "Not Pending",
          "title": "Construct Binary Tree from Inorder and Postorder Traversal",
          "memory": "38.7 MB",
          "code": "/** https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/ */\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        if (inorder.length == 0) {\n            return null;\n        }\n        return buildTree(inorder, 0, inorder.length - 1, postorder, 0, postorder.length - 1);\n    }\n\n    private TreeNode buildTree(int[] inorder, int inStart, int inEnd, int[] postorder, int postStart, int postEnd) {\n        if (inStart > inEnd) {\n            return null;\n        }\n        if (inStart == inEnd) {\n            return new TreeNode(inorder[inStart]);\n        }\n        TreeNode root = new TreeNode(postorder[postEnd]);\n        int i = 0;\n        while (inorder[inStart + i] != postorder[postEnd]) {\n            i++;\n        }\n        root.left = buildTree(inorder, inStart, inStart + i - 1, postorder, postStart, postStart + i - 1);\n        root.right = buildTree(inorder, inStart + i + 1, inEnd, postorder, postStart + i, postEnd - 1);\n        return root;\n    }\n}\n    ",
          "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
          "title_slug": "construct-binary-tree-from-inorder-and-postorder-traversal"
       },
       {
          "id": 595242048,
          "lang": "c",
          "time": "1 hour, 56 minutes",
          "timestamp": 1638331342,
          "status_display": "Accepted",
          "runtime": "12 ms",
          "url": "/submissions/detail/595242048/",
          "is_pending": "Not Pending",
          "title": "Construct Binary Tree from Inorder and Postorder Traversal",
          "memory": "11.8 MB",
          "code": "/** https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/ */\n\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     struct TreeNode *left;\n *     struct TreeNode *right;\n * };\n */\n\n\nstruct TreeNode* buildTree(int* inorder, int inorderSize, int* postorder, int postorderSize){\n    if(inorderSize == 0) return NULL;\n    struct TreeNode* root = malloc(sizeof(struct TreeNode));\n    root->val = postorder[postorderSize - 1];\n    root->left = NULL;\n    root->right = NULL;\n    int i;\n    for(i = 0; i < inorderSize; i++){\n        if(inorder[i] == root->val){\n            root->left = buildTree(inorder, i, postorder, i);\n            root->right = buildTree(inorder + i + 1, inorderSize - i - 1, postorder + i, postorderSize - i - 1);\n        }\n    }\n    return root;\n}\n    ",
          "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
          "title_slug": "construct-binary-tree-from-inorder-and-postorder-traversal"
       },
       {
          "id": 595241943,
          "lang": "javascript",
          "time": "1 hour, 57 minutes",
          "timestamp": 1638331328,
          "status_display": "Wrong Answer",
          "runtime": "N/A",
          "url": "/submissions/detail/595241943/",
          "is_pending": "Not Pending",
          "title": "Combination Sum IV",
          "memory": "N/A",
          "code": "/** https://leetcode.com/problems/combination-sum-iv/ */\n//Given an array of distinct integers nums and a target integer target, return the number of possible combinations that add up to target.\n//The answer is guaranteed to fit in a 32-bit integer.\n\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\n var combinationSum4 = function(nums, target) {\n      \tif (nums.length === 0) return 0;\n \tlet dp = [];\n \tdp[0] = 1;\n \tfor (let i = 1; i <= target; i++) {\n \t\tfor (let j = 0; j < nums.length; j++) {\n \t\t\tif (i - nums[j] >= 0) {\n \t\t\t\tdp[i] += dp[i - nums[j]];\n \t\t\t}\n \t\t}\n \t}\n \treturn dp[target];\n}\n    ",
          "compare_result": "000000000000000",
          "title_slug": "combination-sum-iv"
       },
       {
          "id": 595241828,
          "lang": "python",
          "time": "1 hour, 57 minutes",
          "timestamp": 1638331312,
          "status_display": "Accepted",
          "runtime": "28 ms",
          "url": "/submissions/detail/595241828/",
          "is_pending": "Not Pending",
          "title": "Combination Sum IV",
          "memory": "13.4 MB",
          "code": "# https://leetcode.com/problems/combination-sum-iv/\n#Given an array of distinct integers nums and a target integer target, return the number of possible combinations that add up to target.\n#The answer is guaranteed to fit in a 32-bit integer.\n\nclass Solution(object):\n    def combinationSum4(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        dp = [0] * (target+1)\n        dp[0] = 1\n        for i in range(1, target+1):\n            for num in nums:\n                if i - num >= 0:\n                    dp[i] += dp[i-num]\n        return dp[target]",
          "compare_result": "111111111111111",
          "title_slug": "combination-sum-iv"
       },
       {
          "id": 595241787,
          "lang": "java",
          "time": "1 hour, 57 minutes",
          "timestamp": 1638331306,
          "status_display": "Accepted",
          "runtime": "1 ms",
          "url": "/submissions/detail/595241787/",
          "is_pending": "Not Pending",
          "title": "Combination Sum IV",
          "memory": "36.3 MB",
          "code": "/** https://leetcode.com/problems/combination-sum-iv/ */\n//Given an array of distinct integers nums and a target integer target, return the number of possible combinations that add up to target.\n//The answer is guaranteed to fit in a 32-bit integer.\n\nclass Solution {\n    public int combinationSum4(int[] nums, int target) {\n        if (nums.length == 0 || target < 0) return 0;\n        if (target == 0) return 1;\n        int[] dp = new int[target + 1];\n        dp[0] = 1;\n        for (int i = 1; i <= target; i++) {\n            for (int j = 0; j < nums.length; j++) {\n                if (i >= nums[j]) {\n                    dp[i] += dp[i - nums[j]];\n                }\n            }\n        }\n        return dp[target];\n    }\n}\n    ",
          "compare_result": "111111111111111",
          "title_slug": "combination-sum-iv"
       },
       {
          "id": 595241744,
          "lang": "c",
          "time": "1 hour, 57 minutes",
          "timestamp": 1638331299,
          "status_display": "Runtime Error",
          "runtime": "N/A",
          "url": "/submissions/detail/595241744/",
          "is_pending": "Not Pending",
          "title": "Combination Sum IV",
          "memory": "N/A",
          "code": "/** https://leetcode.com/problems/combination-sum-iv/ */\n//Given an array of distinct integers nums and a target integer target, return the number of possible combinations that add up to target.\n//The answer is guaranteed to fit in a 32-bit integer.\n\n\n\nint combinationSum4(int* nums, int numsSize, int target)\n{\n    int dp[target + 1];\n    memset(dp, 0, sizeof(dp));\n    dp[0] = 1;\n    for (int i = 1; i <= target; i++)\n    {\n        for (int j = 0; j < numsSize; j++)\n        {\n            if (i - nums[j] >= 0)\n            {\n                dp[i] += dp[i - nums[j]];\n            }\n        }\n    }\n    return dp[target];\n}\n    ",
          "compare_result": "111111111111110",
          "title_slug": "combination-sum-iv"
       },
       {
          "id": 595241564,
          "lang": "javascript",
          "time": "1 hour, 58 minutes",
          "timestamp": 1638331272,
          "status_display": "Wrong Answer",
          "runtime": "N/A",
          "url": "/submissions/detail/595241564/",
          "is_pending": "Not Pending",
          "title": "Coin Change",
          "memory": "N/A",
          "code": "/** https://leetcode.com/problems/coin-change/ */\n//You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n//Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\n//You may assume that you have an infinite number of each kind of coin.\n\n/**\n * @param {number[]} coins\n * @param {number} amount\n * @return {number}\n */\n var coinChange = function(coins, amount) {\n         if (amount < 0) {\n        return -1;\n    }\n    if (amount === 0) {\n        return 0;\n    }\n    if (coins.length === 0) {\n        return -1;\n    }\n    var min = Infinity;\n    for (var i = 0; i < coins.length; i++) {\n        var result = coinChange(coins.slice(i + 1), amount - coins[i]);\n        if (result >= 0 && result < min) {\n            min = result + 1;\n        }\n    }\n    return min === Infinity ? -1 : min;\n};\n    ",
          "compare_result": "01110101101110001101111011001000000000000000100001000001000001000100010000000000000000000000000000000000100000001100000000000000000000000000010000000000000000000101100010000000000000011011",
          "title_slug": "coin-change"
       },
       {
          "id": 595241497,
          "lang": "python",
          "time": "1 hour, 58 minutes",
          "timestamp": 1638331263,
          "status_display": "Accepted",
          "runtime": "1192 ms",
          "url": "/submissions/detail/595241497/",
          "is_pending": "Not Pending",
          "title": "Coin Change",
          "memory": "13.9 MB",
          "code": "# https://leetcode.com/problems/coin-change/\n#You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n#Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\n#You may assume that you have an infinite number of each kind of coin.\n\nclass Solution(object):\n    def coinChange(self, coins, amount):\n        \"\"\"\n        :type coins: List[int]\n        :type amount: int\n        :rtype: int\n        \"\"\"\n        dp = [0] + [float(\"inf\")] * amount\n        for i in range(1, amount + 1):\n            for coin in coins:\n                if i >= coin:\n                    dp[i] = min(dp[i], dp[i - coin] + 1)\n        return dp[-1] if dp[-1] != float(\"inf\") else -1",
          "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
          "title_slug": "coin-change"
       },
       {
          "id": 595241456,
          "lang": "java",
          "time": "1 hour, 58 minutes",
          "timestamp": 1638331257,
          "status_display": "Accepted",
          "runtime": "12 ms",
          "url": "/submissions/detail/595241456/",
          "is_pending": "Not Pending",
          "title": "Coin Change",
          "memory": "38.7 MB",
          "code": "/** https://leetcode.com/problems/coin-change/ */\n//You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n//Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\n//You may assume that you have an infinite number of each kind of coin.\n\nclass Solution {\n    public int coinChange(int[] coins, int amount) {\n        int[] dp = new int[amount + 1];\n        Arrays.fill(dp, amount + 1);\n        dp[0] = 0;\n        for (int i = 1; i <= amount; i++) {\n            for (int coin : coins) {\n                if (i >= coin) {\n                    dp[i] = Math.min(dp[i], dp[i - coin] + 1);\n                }\n            }\n        }\n        return dp[amount] > amount ? -1 : dp[amount];\n    }\n}\n    ",
          "compare_result": "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
          "title_slug": "coin-change"
       },
       {
          "id": 595241372,
          "lang": "c",
          "time": "1 hour, 58 minutes",
          "timestamp": 1638331245,
          "status_display": "Compile Error",
          "runtime": "N/A",
          "url": "/submissions/detail/595241372/",
          "is_pending": "Not Pending",
          "title": "Coin Change",
          "memory": "N/A",
          "code": "/** https://leetcode.com/problems/coin-change/ */\n//You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n//Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\n//You may assume that you have an infinite number of each kind of coin.\n\n\n\nint coinChange(int* coins, int coinsSize, int amount){\n    int *dp = malloc(sizeof(int) * (amount + 1));\n    memset(dp, 0, sizeof(int) * (amount + 1));\n    dp[0] = 0;\n    for(int i = 1; i <= amount; i++){\n        dp[i] = INT_MAX;\n        for(int j = 0; j < coinsSize; j++){\n            if(i - coins[j] >= 0 && dp[i - coins[j]] != INT_MAX){\n                dp[i] = min(dp[i], dp[i - coins[j]] + 1);\n            }\n        }\n    }\n    int result = dp[amount];\n    free(dp);\n    return result == INT_MAX ? -1 : result;\n}\n    ",
          "compare_result": null,
          "title_slug": "coin-change"
       },
       {
          "id": 595222039,
          "lang": "javascript",
          "time": "2 hours, 43 minutes",
          "timestamp": 1638328527,
          "status_display": "Wrong Answer",
          "runtime": "N/A",
          "url": "/submissions/detail/595222039/",
          "is_pending": "Not Pending",
          "title": "Burst Balloons",
          "memory": "N/A",
          "code": "/** https://leetcode.com/problems/burst-balloons/ */\n//You are given n balloons, indexed from 0 to n - 1. Each balloon is painted with a number on it represented by an array nums. You are asked to burst all the balloons.\n//If you burst the ith balloon, you will get nums[i - 1] * nums[i] * nums[i + 1] coins. If i - 1 or i + 1 goes out of bounds of the array, then treat it as if there is a balloon with a 1 painted on it.\n//Return the maximum coins you can collect by bursting the balloons wisely.\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\n var maxCoins = function(nums) {\n    var balloons = nums.map(function(n){ return n ? n : 1; });\n//console.log(balloons);\nvar max = 0;\nfor (var i = 0; i < balloons.length; i++) {\n   for (var j = i + 1; j < balloons.length; j++) {\n       for (var k = j + 1; k < balloons.length; k++) {\n           var val = balloons[i - 1] * balloons[i] * balloons[j] * balloons[k];\n           max = Math.max(max, val);\n       }\n   }\n}\nreturn max;\n};\n",
          "compare_result": "0000000000000000000000000000000000000000000000000000000000000000000000",
          "title_slug": "burst-balloons"
       },
       {
          "id": 595221664,
          "lang": "javascript",
          "time": "2 hours, 44 minutes",
          "timestamp": 1638328472,
          "status_display": "Runtime Error",
          "runtime": "N/A",
          "url": "/submissions/detail/595221664/",
          "is_pending": "Not Pending",
          "title": "Burst Balloons",
          "memory": "N/A",
          "code": "/** https://leetcode.com/problems/burst-balloons/ */\n//You are given n balloons, indexed from 0 to n - 1. Each balloon is painted with a number on it represented by an array nums. You are asked to burst all the balloons.\n//If you burst the ith balloon, you will get nums[i - 1] * nums[i] * nums[i + 1] coins. If i - 1 or i + 1 goes out of bounds of the array, then treat it as if there is a balloon with a 1 painted on it.\n//Return the maximum coins you can collect by bursting the balloons wisely.\n\nclass Solution {\n    public int maxCoins(int[] nums) {\n        int n = nums.length;\n        int[] arr = new int[n + 2];\n        arr[0] = 1;\n        arr[n + 1] = 1;\n        for (int i = 1; i <= n; i++) {\n            arr[i] = nums[i - 1];\n        }\n        int[][] dp = new int[n + 2][n + 2];\n        for (int len = 2; len <= n; len++) {\n            for (int i = 1; i <= n - len + 1; i++) {\n                int j = i + len - 1;\n                for (int k = i; k <= j; k++) {\n                    dp[i][j] = Math.max(dp[i][j], arr[i - 1] * arr[k] * arr[j + 1] + dp[i][k - 1] + dp[k + 1][j]);\n                }\n            }\n        }\n        return dp[1][n];\n    }\n}",
          "compare_result": "0000000000000000000000000000000000000000000000000000000000000000000000",
          "title_slug": "burst-balloons"
       },
       {
          "id": 595221545,
          "lang": "python",
          "time": "2 hours, 45 minutes",
          "timestamp": 1638328455,
          "status_display": "Accepted",
          "runtime": "6736 ms",
          "url": "/submissions/detail/595221545/",
          "is_pending": "Not Pending",
          "title": "Burst Balloons",
          "memory": "18.5 MB",
          "code": "# https://leetcode.com/problems/burst-balloons/\n#You are given n balloons, indexed from 0 to n - 1. Each balloon is painted with a number on it represented by an array nums. You are asked to burst all the balloons.\n#If you burst the ith balloon, you will get nums[i - 1] * nums[i] * nums[i + 1] coins. If i - 1 or i + 1 goes out of bounds of the array, then treat it as if there is a balloon with a 1 painted on it.\n#Return the maximum coins you can collect by bursting the balloons wisely.\n\nclass Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        for l in range(2, n):\n            for i in range(n - l):\n                j = i + l\n                for k in range(i + 1, j):\n                    dp[i][j] = max(dp[i][j], nums[i] * nums[k] * nums[j] + dp[i][k] + dp[k][j])\n        return dp[0][n - 1]",
          "compare_result": "1111111111111111111111111111111111111111111111111111111111111111111111",
          "title_slug": "burst-balloons"
       },
       {
          "id": 595221500,
          "lang": "java",
          "time": "2 hours, 45 minutes",
          "timestamp": 1638328449,
          "status_display": "Wrong Answer",
          "runtime": "N/A",
          "url": "/submissions/detail/595221500/",
          "is_pending": "Not Pending",
          "title": "Burst Balloons",
          "memory": "N/A",
          "code": "/** https://leetcode.com/problems/burst-balloons/ */\n//You are given n balloons, indexed from 0 to n - 1. Each balloon is painted with a number on it represented by an array nums. You are asked to burst all the balloons.\n//If you burst the ith balloon, you will get nums[i - 1] * nums[i] * nums[i + 1] coins. If i - 1 or i + 1 goes out of bounds of the array, then treat it as if there is a balloon with a 1 painted on it.\n//Return the maximum coins you can collect by bursting the balloons wisely.\n\nclass Solution {\n    public int maxCoins(int[] nums) {\n        int n = nums.length;\n        int[] arr = new int[n + 2];\n        arr[0] = 1;\n        arr[n + 1] = 1;\n        for (int i = 1; i <= n; i++) {\n            arr[i] = nums[i - 1];\n        }\n        int[][] dp = new int[n + 2][n + 2];\n        for (int len = 2; len <= n; len++) {\n            for (int i = 1; i <= n - len + 1; i++) {\n                int j = i + len - 1;\n                for (int k = i; k <= j; k++) {\n                    dp[i][j] = Math.max(dp[i][j], arr[i - 1] * arr[k] * arr[j + 1] + dp[i][k - 1] + dp[k + 1][j]);\n                }\n            }\n        }\n        return dp[1][n];\n    }\n}",
          "compare_result": "0000000000000000000000000000000000000000000000000000000000000000000000",
          "title_slug": "burst-balloons"
       },
       {
          "id": 595221428,
          "lang": "c",
          "time": "2 hours, 45 minutes",
          "timestamp": 1638328438,
          "status_display": "Runtime Error",
          "runtime": "N/A",
          "url": "/submissions/detail/595221428/",
          "is_pending": "Not Pending",
          "title": "Burst Balloons",
          "memory": "N/A",
          "code": "/** https://leetcode.com/problems/burst-balloons/ */\n//You are given n balloons, indexed from 0 to n - 1. Each balloon is painted with a number on it represented by an array nums. You are asked to burst all the balloons.\n//If you burst the ith balloon, you will get nums[i - 1] * nums[i] * nums[i + 1] coins. If i - 1 or i + 1 goes out of bounds of the array, then treat it as if there is a balloon with a 1 painted on it.\n//Return the maximum coins you can collect by bursting the balloons wisely.\n\n\n\nint maxCoins(int* nums, int numsSize){\n    int *nums_copy = (int*)malloc(sizeof(int) * numsSize);\n    memcpy(nums_copy, nums, sizeof(int) * numsSize);\n    int *dp = (int*)malloc(sizeof(int) * (numsSize + 2));\n    memset(dp, 0, sizeof(int) * (numsSize + 2));\n    dp[0] = 1;\n    dp[numsSize + 1] = 1;\n    for(int i = 1; i <= numsSize; i++){\n        dp[i] = nums_copy[i - 1];\n    }\n    for(int i = 1; i <= numsSize; i++){\n        for(int j = 1; j <= numsSize; j++){\n            int left = i - 1;\n            int right = j + 1;\n            while(left >= 1 && right <= numsSize){\n                dp[i] = fmax(dp[i], dp[left] * dp[right] * nums_copy[i - 1]);\n                left--;\n                right++;\n            }\n        }\n    }\n    return dp[numsSize];\n}\n    ",
          "compare_result": "0000000000000000000000000000000000000000000000000000000000000000000000",
          "title_slug": "burst-balloons"
       },
       {
          "id": 595221258,
          "lang": "javascript",
          "time": "2 hours, 45 minutes",
          "timestamp": 1638328411,
          "status_display": "Runtime Error",
          "runtime": "N/A",
          "url": "/submissions/detail/595221258/",
          "is_pending": "Not Pending",
          "title": "Split Array Largest Sum",
          "memory": "N/A",
          "code": "/** https://leetcode.com/problems/split-array-largest-sum/ */\n//Given an array nums which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays.\n//Write an algorithm to minimize the largest sum among these m subarrays.\n\n/**\n * @param {number[]} nums\n * @param {number} m\n * @return {number}\n */\n var splitArray = function(nums, m) {\n    let max = 0;\nfor (let i = 0; i < nums.length; i++) {\n   max = Math.max(max, nums[i]);\n}\nlet l = max;\nlet r = max * nums.length;\nwhile (l < r) {\n   let mid = Math.floor((l + r) / 2);\n   if (canSplit(nums, m, mid)) {\n       r = mid;\n   } else {\n       l = mid + 1;\n   }\n}\nreturn l;\n}\n",
          "compare_result": "000000000000000000000000000000",
          "title_slug": "split-array-largest-sum"
       },
       {
          "id": 595221212,
          "lang": "python",
          "time": "2 hours, 45 minutes",
          "timestamp": 1638328405,
          "status_display": "Runtime Error",
          "runtime": "N/A",
          "url": "/submissions/detail/595221212/",
          "is_pending": "Not Pending",
          "title": "Split Array Largest Sum",
          "memory": "N/A",
          "code": "# https://leetcode.com/problems/split-array-largest-sum/\n#Given an array nums which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays.\n#Write an algorithm to minimize the largest sum among these m subarrays.\n\nclass Solution(object):\n    def splitArray(self, nums, m):\n        \"\"\"\n        :type nums: List[int]\n        :type m: int\n        :rtype: int\n        \"\"\"\n        if len(nums) < m:\n            return 0\n        if m == 1:\n            return max(nums)\n        if m == len(nums):\n            return sum(nums)\n        left = max(nums)\n        right = sum(nums)\n        while left <= right:\n            mid = (left + right) // 2\n            if self.canSplit(nums, m, mid):\n                right = mid - 1\n            else:\n                left = mid + 1\n        return left",
          "compare_result": "000000000000000000000000000000",
          "title_slug": "split-array-largest-sum"
       },
       {
          "id": 595221170,
          "lang": "java",
          "time": "2 hours, 46 minutes",
          "timestamp": 1638328398,
          "status_display": "Accepted",
          "runtime": "69 ms",
          "url": "/submissions/detail/595221170/",
          "is_pending": "Not Pending",
          "title": "Split Array Largest Sum",
          "memory": "36.7 MB",
          "code": "/** https://leetcode.com/problems/split-array-largest-sum/ */\n//Given an array nums which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays.\n//Write an algorithm to minimize the largest sum among these m subarrays.\n\nclass Solution {\n    public int splitArray(int[] nums, int m) {\n        int n = nums.length;\n        int[] sums = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            sums[i] = sums[i - 1] + nums[i - 1];\n        }\n        int[][] dp = new int[m + 1][n + 1];\n        for (int i = 1; i <= n; i++) {\n            dp[1][i] = sums[i];\n        }\n        for (int i = 2; i <= m; i++) {\n            for (int j = i; j <= n; j++) {\n                dp[i][j] = Integer.MAX_VALUE;\n                for (int k = i - 1; k < j; k++) {\n                    dp[i][j] = Math.min(dp[i][j], Math.max(dp[i - 1][k], sums[j] - sums[k]));\n                }\n            }\n        }\n        return dp[m][n];\n    }\n}\n    ",
          "compare_result": "111111111111111111111111111111",
          "title_slug": "split-array-largest-sum"
       },
       {
          "id": 595221041,
          "lang": "c",
          "time": "2 hours, 46 minutes",
          "timestamp": 1638328381,
          "status_display": "Accepted",
          "runtime": "0 ms",
          "url": "/submissions/detail/595221041/",
          "is_pending": "Not Pending",
          "title": "Split Array Largest Sum",
          "memory": "5.8 MB",
          "code": "/** https://leetcode.com/problems/split-array-largest-sum/ */\n//Given an array nums which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays.\n//Write an algorithm to minimize the largest sum among these m subarrays.\n\nbool check(int* nums, int numsSize, int mid, int m) {\n    int cur = 0;\n    int count = 1;\n    for (int i = 0; i < numsSize; i++) {\n        if (cur + nums[i] > mid) {\n            count++;\n            cur = nums[i];\n        } else {\n            cur += nums[i];\n        }\n        if (count > m) return false;\n    }\n    return true;\n}\n\nint splitArray(int* nums, int numsSize, int m){\n    int max = 0, sum = 0;\n    for (int i = 0; i < numsSize; i++) {\n        sum += nums[i];\n        max = max > nums[i] ? max : nums[i];\n    }\n    if (m == 1) return sum;\n    int l = max, r = sum;\n    while (l < r) {\n        int mid = l + (r - l) / 2;\n        if (check(nums, numsSize, mid, m)) {\n            r = mid;\n        } else {\n            l = mid + 1;\n        }\n    }\n    return l;\n}\n\n\n    ",
          "compare_result": "111111111111111111111111111111",
          "title_slug": "split-array-largest-sum"
       },
       {
          "id": 595220495,
          "lang": "javascript",
          "time": "2 hours, 47 minutes",
          "timestamp": 1638328303,
          "status_display": "Time Limit Exceeded",
          "runtime": "N/A",
          "url": "/submissions/detail/595220495/",
          "is_pending": "Not Pending",
          "title": "Number of Digit One",
          "memory": "N/A",
          "code": "/** https://leetcode.com/problems/number-of-digit-one/ */\n\n/**\n * Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n.\n */\n/**\n * @param {number} n\n * @return {number}\n */\n var countDigitOne = function(n) {\n         let count = 0;\n    for (let i = 1; i <= n; i++) {\n        let num = i;\n        while (num > 0) {\n            if (num % 10 === 1) {\n                count++;\n            }\n            num = Math.floor(num / 10);\n        }\n    }\n    return count;\n};\n    ",
          "compare_result": "11111111111111111111111111111111111000",
          "title_slug": "number-of-digit-one"
       }
    ],
    "has_next": true,
    "last_key": "%7B%22pk%22%3A%20%7B%22N%22%3A%20%22595220495%22%7D%2C%20%22dt%22%3A%20%7B%22S%22%3A%20%222021-12-01T03%3A11%3A43.042820%2B0000%22%7D%2C%20%22sid%22%3A%20%7B%22N%22%3A%20%225508277%22%7D%7D"
 }