{
    "submissions_dump": [
       {
          "id": 595216731,
          "lang": "python",
          "time": "2 hours, 59 minutes",
          "timestamp": 1638327721,
          "status_display": "Wrong Answer",
          "runtime": "N/A",
          "url": "/submissions/detail/595216731/",
          "is_pending": "Not Pending",
          "title": "Count Numbers with Unique Digits",
          "memory": "N/A",
          "code": "# https://leetcode.com/problems/count-numbers-with-unique-digits/\n#Given an integer n, return the count of all numbers with unique digits, x, where 0 <= x < 10n.\n\nclass Solution(object):\n    def countNumbersWithUniqueDigits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if n == 0:\n            return 1\n        if n == 1:\n            return 10\n        if n > 10:\n            return 0\n        if n == 2:\n            return 9 * 9\n        if n == 3:\n            return 9 * 9 * 8\n        if n == 4:\n            return 9 * 9 * 8 * 7\n        if n == 5:\n            return 9 * 9 * 8 * 7 * 6\n        if n == 6:\n            return 9 * 9 * 8 * 7 * 6 * 5\n        if n == 7:\n            return 9 * 9 * 8 * 7 * 6 * 5 * 4\n        if n == 8:\n            return 9 * 9 * 8 * 7 * 6 * 5 * 4 * 3\n        if n == 9:\n            return 9 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2",
          "compare_result": "011000000",
          "title_slug": "count-numbers-with-unique-digits"
       },
       {
          "id": 595216617,
          "lang": "java",
          "time": "2 hours, 59 minutes",
          "timestamp": 1638327706,
          "status_display": "Wrong Answer",
          "runtime": "N/A",
          "url": "/submissions/detail/595216617/",
          "is_pending": "Not Pending",
          "title": "Count Numbers with Unique Digits",
          "memory": "N/A",
          "code": "/** https://leetcode.com/problems/count-numbers-with-unique-digits/ */\n//Given an integer n, return the count of all numbers with unique digits, x, where 0 <= x < 10n.\n\nclass Solution {\n    public int countNumbersWithUniqueDigits(int n) {\n        int[] dp = new int[n + 1];\n        dp[0] = 1;\n        dp[1] = 10;\n        for (int i = 2; i <= n; i++) {\n            dp[i] = dp[i - 1] * (11 - i);\n        }\n        int ans = dp[n];\n        for (int i = 1; i <= 9; i++) {\n            ans += dp[n - 1];\n        }\n        return ans;\n    }\n}\n    ",
          "compare_result": "000000000",
          "title_slug": "count-numbers-with-unique-digits"
       },
       {
          "id": 595216427,
          "lang": "c",
          "time": "2 hours, 59 minutes",
          "timestamp": 1638327679,
          "status_display": "Accepted",
          "runtime": "0 ms",
          "url": "/submissions/detail/595216427/",
          "is_pending": "Not Pending",
          "title": "Count Numbers with Unique Digits",
          "memory": "5.7 MB",
          "code": "/** https://leetcode.com/problems/count-numbers-with-unique-digits/ */\n//Given an integer n, return the count of all numbers with unique digits, x, where 0 <= x < 10n.\n\n\n\nint countNumbersWithUniqueDigits(int n){\n    if(n==0) return 1;\n    int res=10;\n    int base=9;\n    for(int i=2;i<=n;i++){\n        base*=10-i+1;\n        res+=base;\n    }\n    return res;\n}\n    ",
          "compare_result": "111111111",
          "title_slug": "count-numbers-with-unique-digits"
       },
       {
          "id": 595216045,
          "lang": "javascript",
          "time": "3 hours",
          "timestamp": 1638327626,
          "status_display": "Runtime Error",
          "runtime": "N/A",
          "url": "/submissions/detail/595216045/",
          "is_pending": "Not Pending",
          "title": "Concatenated Words",
          "memory": "N/A",
          "code": "/** https://leetcode.com/problems/concatenated-words/ */\n//Given an array of strings words (without duplicates), return all the concatenated words in the given list of words.\n//A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.\n\n/**\n * @param {string[]} words\n * @return {string[]}\n */\n var findAllConcatenatedWordsInADict = function(words) {\n         let res = [];\n    for(let i=0; i<words.length; i++){\n        if(isConcatenated(words[i])){\n            res.push(words[i]);\n        }\n    }\n    return res;\n}\n    ",
          "compare_result": "00000000000000000000000000000000000000000000",
          "title_slug": "concatenated-words"
       },
       {
          "id": 595215822,
          "lang": "python",
          "time": "3 hours, 1 minute",
          "timestamp": 1638327596,
          "status_display": "Wrong Answer",
          "runtime": "N/A",
          "url": "/submissions/detail/595215822/",
          "is_pending": "Not Pending",
          "title": "Concatenated Words",
          "memory": "N/A",
          "code": "# https://leetcode.com/problems/concatenated-words/\n#Given an array of strings words (without duplicates), return all the concatenated words in the given list of words.\n#A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.\n\nclass Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        def dfs(word, dic):\n            if word in dic:\n                return True\n            for i in range(1, len(word)):\n                if word[:i] in dic and dfs(word[i:], dic):\n                    return True\n            return False\n        dic = set(words)\n        res = []\n        for word in words:\n            if dfs(word, dic):\n                res.append(word)\n        return res",
          "compare_result": "00000000000000000000000000000000000000000000",
          "title_slug": "concatenated-words"
       },
       {
          "id": 595215739,
          "lang": "java",
          "time": "3 hours, 1 minute",
          "timestamp": 1638327584,
          "status_display": "Wrong Answer",
          "runtime": "N/A",
          "url": "/submissions/detail/595215739/",
          "is_pending": "Not Pending",
          "title": "Concatenated Words",
          "memory": "N/A",
          "code": "/** https://leetcode.com/problems/concatenated-words/ */\n//Given an array of strings words (without duplicates), return all the concatenated words in the given list of words.\n//A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.\n\nclass Solution {\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\n        List<String> res = new ArrayList<>();\n        if (words == null || words.length == 0) return res;\n        Arrays.sort(words, (a, b) -> a.length() - b.length());\n        for (String word : words) {\n            if (word.length() == 0 || !isConcatenated(word, words)) continue;\n            res.add(word);\n        }\n        return res;\n    }\n    private boolean isConcatenated(String word, String[] words) {\n        boolean[] visited = new boolean[word.length() + 1];\n        for (int i = 0; i < word.length(); i++) {\n            if (dfs(word, i, 0, words, visited)) return true;\n        }\n        return false;\n    }\n    private boolean dfs(String word, int index, int count, String[] words, boolean[] visited) {\n        if (count == words.length) {\n            return index == word.length();\n        }\n        if (index == word.length()) return false;\n        for (int i = index + 1; i <= word.length(); i++) {\n            if (visited[i]) continue;\n            if (i - index > words[count].length()) continue;\n            if (!word.substring(index, i).equals(words[count])) continue;\n            visited[i] = true;\n            if (dfs(word, i, count + 1, words, visited)) return true;\n            visited[i] = false;\n        }\n        return false;\n    }\n}\n    ",
          "compare_result": "00100000000111111011111111100110110111011110",
          "title_slug": "concatenated-words"
       },
       {
          "id": 595215677,
          "lang": "c",
          "time": "3 hours, 1 minute",
          "timestamp": 1638327573,
          "status_display": "Wrong Answer",
          "runtime": "N/A",
          "url": "/submissions/detail/595215677/",
          "is_pending": "Not Pending",
          "title": "Concatenated Words",
          "memory": "N/A",
          "code": "/** https://leetcode.com/problems/concatenated-words/ */\n//Given an array of strings words (without duplicates), return all the concatenated words in the given list of words.\n//A concatenated word is defined as a string that is comprised entirely of at least two shorter words in the given array.\n\n\n\n/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\n\nbool isConcatenatedHelper(char **words, int wordsSize, char *word, int *visited) {\n    if (strlen(word) == 0) {\n        return true;\n    }\n    for (int i = 0; i < wordsSize; i++) {\n        if (visited[i] == 1) {\n            continue;\n        }\n        if (strlen(words[i]) > strlen(word)) {\n            continue;\n        }\n        if (strstr(words[i], word) != NULL) {\n            visited[i] = 1;\n            if (isConcatenatedHelper(words, wordsSize, word + strlen(words[i]), visited)) {\n                return true;\n            }\n            visited[i] = 0;\n        }\n    }\n    return false;\n}\n\nbool isConcatenated(char **words, int wordsSize, char *word) {\n    int *visited = (int *)malloc(sizeof(int) * wordsSize);\n    memset(visited, 0, sizeof(int) * wordsSize);\n    return isConcatenatedHelper(words, wordsSize, word, visited);\n}\n\n\nchar ** findAllConcatenatedWordsInADict(char ** words, int wordsSize, int* returnSize){\n    *returnSize = 0;\n    if (wordsSize == 0) {\n        return NULL;\n    }\n    char **res = (char **)malloc(sizeof(char *) * wordsSize);\n    for (int i = 0; i < wordsSize; i++) {\n        if (isConcatenated(words, wordsSize, words[i])) {\n            res[*returnSize] = words[i];\n            (*returnSize)++;\n        }\n    }\n    return res;\n}\n\n\n    ",
          "compare_result": "00000000000000000000000000000000000000000000",
          "title_slug": "concatenated-words"
       },
       {
          "id": 595215394,
          "lang": "javascript",
          "time": "3 hours, 2 minutes",
          "timestamp": 1638327529,
          "status_display": "Runtime Error",
          "runtime": "N/A",
          "url": "/submissions/detail/595215394/",
          "is_pending": "Not Pending",
          "title": "Can I Win",
          "memory": "N/A",
          "code": "/** https://leetcode.com/problems/can-i-win/ */\n//In the \"100 game\" two players take turns adding, to a running total, any integer from 1 to 10. The player who first causes the running total to reach or exceed 100 wins.\n//What if we change the game so that players cannot re-use integers?\n//For example, two players might take turns drawing from a common pool of numbers from 1 to 15 without replacement until they reach a total >= 100.\n//Given two integers maxChoosableInteger and desiredTotal, return true if the first player to move can force a win, otherwise, return false. Assume both players play optimally.\n\n/**\n * @param {number} maxChoosableInteger\n * @param {number} desiredTotal\n * @return {boolean}\n */\n var canIWin = function(maxChoosableInteger, desiredTotal) {\n      \tif (desiredTotal <= 0) return true;\n \tif (maxChoosableInteger * (maxChoosableInteger + 1) / 2 < desiredTotal) return false;\n \tlet dp = {};\n \treturn helper(maxChoosableInteger, desiredTotal, dp);\n }\n    ",
          "compare_result": "000000000000000000000000000000000000000000000000000000000",
          "title_slug": "can-i-win"
       },
       {
          "id": 595214987,
          "lang": "python",
          "time": "3 hours, 3 minutes",
          "timestamp": 1638327465,
          "status_display": "Runtime Error",
          "runtime": "N/A",
          "url": "/submissions/detail/595214987/",
          "is_pending": "Not Pending",
          "title": "Can I Win",
          "memory": "N/A",
          "code": "# https://leetcode.com/problems/can-i-win/\n#In the \"100 game\" two players take turns adding, to a running total, any integer from 1 to 10. The player who first causes the running total to reach or exceed 100 wins.\n#What if we change the game so that players cannot re-use integers?\n#For example, two players might take turns drawing from a common pool of numbers from 1 to 15 without replacement until they reach a total >= 100.\n#Given two integers maxChoosableInteger and desiredTotal, return true if the first player to move can force a win, otherwise, return false. Assume both players play optimally.\n\nclass Solution(object):\n    def canIWin(self, maxChoosableInteger, desiredTotal):\n        \"\"\"\n        :type maxChoosableInteger: int\n        :type desiredTotal: int\n        :rtype: bool\n        \"\"\"\n        if maxChoosableInteger * (maxChoosableInteger + 1) / 2 < desiredTotal:\n            return False\n        if desiredTotal <= 0:\n            return True\n        self.memo = {}\n        return self.dfs(maxChoosableInteger, desiredTotal)    \n    ",
          "compare_result": "000000000000000000000000000000000000000000000000000000000",
          "title_slug": "can-i-win"
       },
       {
          "id": 595214828,
          "lang": "java",
          "time": "3 hours, 3 minutes",
          "timestamp": 1638327442,
          "status_display": "Wrong Answer",
          "runtime": "N/A",
          "url": "/submissions/detail/595214828/",
          "is_pending": "Not Pending",
          "title": "Can I Win",
          "memory": "N/A",
          "code": "/** https://leetcode.com/problems/can-i-win/ */\n//In the \"100 game\" two players take turns adding, to a running total, any integer from 1 to 10. The player who first causes the running total to reach or exceed 100 wins.\n//What if we change the game so that players cannot re-use integers?\n//For example, two players might take turns drawing from a common pool of numbers from 1 to 15 without replacement until they reach a total >= 100.\n//Given two integers maxChoosableInteger and desiredTotal, return true if the first player to move can force a win, otherwise, return false. Assume both players play optimally.\n\nclass Solution {\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\n        if (desiredTotal <= 0) return true;\n        if (maxChoosableInteger * (maxChoosableInteger + 1) / 2 < desiredTotal) return false;\n        boolean[] dp = new boolean[1 << maxChoosableInteger];\n        return helper(dp, maxChoosableInteger, desiredTotal);\n    }\n    \n    private boolean helper(boolean[] dp, int maxChoosableInteger, int desiredTotal) {\n        if (desiredTotal <= 0) return false;\n        if (maxChoosableInteger <= 0) return true;\n        int mask = 1 << maxChoosableInteger;\n        if (dp[mask - 1]) return true;\n        for (int i = 1; i <= maxChoosableInteger; i++) {\n            if ((mask & (1 << i)) == 0) {\n                if (!helper(dp, maxChoosableInteger - 1, desiredTotal - i)) {\n                    dp[mask - 1] = true;\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n    ",
          "compare_result": "011011101101101101111101111011010101100100011100011100100",
          "title_slug": "can-i-win"
       },
       {
          "id": 595214598,
          "lang": "c",
          "time": "3 hours, 4 minutes",
          "timestamp": 1638327406,
          "status_display": "Compile Error",
          "runtime": "N/A",
          "url": "/submissions/detail/595214598/",
          "is_pending": "Not Pending",
          "title": "Can I Win",
          "memory": "N/A",
          "code": "/** https://leetcode.com/problems/can-i-win/ */\n//In the \"100 game\" two players take turns adding, to a running total, any integer from 1 to 10. The player who first causes the running total to reach or exceed 100 wins.\n//What if we change the game so that players cannot re-use integers?\n//For example, two players might take turns drawing from a common pool of numbers from 1 to 15 without replacement until they reach a total >= 100.\n//Given two integers maxChoosableInteger and desiredTotal, return true if the first player to move can force a win, otherwise, return false. Assume both players play optimally.\n\nbool helper(vector<int>& nums, int desiredTotal, int cur, vector<vector<int>>& dp) {\n    if (cur >= nums.size()) return false;\n    if (dp[cur][desiredTotal] != -1) return dp[cur][desiredTotal];\n    for (int i = 0; i < nums.size(); i++) {\n        if (nums[i] > desiredTotal) continue;\n        if (nums[i] > 0 && helper(nums, desiredTotal - nums[i], i + 1, dp)) {\n            dp[cur][desiredTotal] = true;\n            return true;\n        }\n    }\n    dp[cur][desiredTotal] = false;\n    return false;\n}\n\nbool canIWin(int maxChoosableInteger, int desiredTotal){\n    if (desiredTotal <= 0) return true;\n    if (maxChoosableInteger * (maxChoosableInteger + 1) / 2 < desiredTotal) return false;\n    if (maxChoosableInteger == 1) return true;\n    vector<int> nums;\n    for (int i = 1; i <= maxChoosableInteger; i++) {\n        nums.push_back(i);\n    }\n    vector<vector<int>> dp(maxChoosableInteger + 1, vector<int>(desiredTotal + 1, -1));\n    return helper(nums, desiredTotal, 0, dp);\n}\n\n\n    ",
          "compare_result": null,
          "title_slug": "can-i-win"
       },
       {
          "id": 595213898,
          "lang": "javascript",
          "time": "3 hours, 6 minutes",
          "timestamp": 1638327302,
          "status_display": "Wrong Answer",
          "runtime": "N/A",
          "url": "/submissions/detail/595213898/",
          "is_pending": "Not Pending",
          "title": "Best Time to Buy and Sell Stock with Cooldown",
          "memory": "N/A",
          "code": "/** https://leetcode.com/problems/longest-increasing-subsequence/ */\n//You are given an array prices where prices[i] is the price of a given stock on the ith day.\n//Find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:\n//After you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).\n//Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n\n/**\n * @param {number[]} prices\n * @return {number}\n */\n var maxProfit = function(prices) {\n         var profit = 0;\n    for (var i = 1; i < prices.length; i++) {\n        if (prices[i] > prices[i-1]) {\n            profit += (prices[i] - prices[i-1]);\n        }\n    }\n    return profit;\n};\n    ",
          "compare_result": "011111111111101001100000110101110101111101111111110101000101001001001011110101000101001001001011110101110101001001001011110101110101111101001011110101110101111101111111110000000000000000000000001000001000110000",
          "title_slug": "best-time-to-buy-and-sell-stock-with-cooldown"
       },
       {
          "id": 595213509,
          "lang": "c",
          "time": "3 hours, 7 minutes",
          "timestamp": 1638327242,
          "status_display": "Compile Error",
          "runtime": "N/A",
          "url": "/submissions/detail/595213509/",
          "is_pending": "Not Pending",
          "title": "Best Time to Buy and Sell Stock with Cooldown",
          "memory": "N/A",
          "code": "/** https://leetcode.com/problems/longest-increasing-subsequence/ */\n//You are given an array prices where prices[i] is the price of a given stock on the ith day.\n//Find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:\n//After you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).\n//Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int maxProfit = 0;\n        for (int i = 0; i < prices.length - 1; i++) {\n            for (int j = i + 1; j < prices.length; j++) {\n                if (prices[j] > prices[i]) {\n                    maxProfit += prices[j] - prices[i];\n                }\n            }\n        }\n        return maxProfit;\n    }\n}\n    ",
          "compare_result": null,
          "title_slug": "best-time-to-buy-and-sell-stock-with-cooldown"
       },
       {
          "id": 595213469,
          "lang": "python",
          "time": "3 hours, 7 minutes",
          "timestamp": 1638327237,
          "status_display": "Wrong Answer",
          "runtime": "N/A",
          "url": "/submissions/detail/595213469/",
          "is_pending": "Not Pending",
          "title": "Best Time to Buy and Sell Stock with Cooldown",
          "memory": "N/A",
          "code": "# https://leetcode.com/problems/longest-increasing-subsequence/\n#You are given an array prices where prices[i] is the price of a given stock on the ith day.\n#Find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:\n#After you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).\n#Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n\nclass Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        if len(prices) < 2:\n            return 0\n        profit = 0\n        for i in range(1, len(prices)):\n            if prices[i] > prices[i-1]:\n                profit += prices[i] - prices[i-1]\n        return profit",
          "compare_result": "011111111111101001100000110101110101111101111111110101000101001001001011110101000101001001001011110101110101001001001011110101110101111101001011110101110101111101111111110000000000000000000000001000001000110000",
          "title_slug": "best-time-to-buy-and-sell-stock-with-cooldown"
       },
       {
          "id": 595213424,
          "lang": "java",
          "time": "3 hours, 7 minutes",
          "timestamp": 1638327229,
          "status_display": "Wrong Answer",
          "runtime": "N/A",
          "url": "/submissions/detail/595213424/",
          "is_pending": "Not Pending",
          "title": "Best Time to Buy and Sell Stock with Cooldown",
          "memory": "N/A",
          "code": "/** https://leetcode.com/problems/longest-increasing-subsequence/ */\n//You are given an array prices where prices[i] is the price of a given stock on the ith day.\n//Find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:\n//After you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).\n//Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int maxProfit = 0;\n        for (int i = 0; i < prices.length - 1; i++) {\n            for (int j = i + 1; j < prices.length; j++) {\n                if (prices[j] > prices[i]) {\n                    maxProfit += prices[j] - prices[i];\n                }\n            }\n        }\n        return maxProfit;\n    }\n}\n    ",
          "compare_result": "011110001110100000000000000000000000000001000111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011000000000000000001000111000000000000000000000000000000000000010000",
          "title_slug": "best-time-to-buy-and-sell-stock-with-cooldown"
       },
       {
          "id": 595212555,
          "lang": "javascript",
          "time": "3 hours, 9 minutes",
          "timestamp": 1638327089,
          "status_display": "Runtime Error",
          "runtime": "N/A",
          "url": "/submissions/detail/595212555/",
          "is_pending": "Not Pending",
          "title": "Longest Increasing Subsequence",
          "memory": "N/A",
          "code": "/** https://leetcode.com/problems/longest-increasing-subsequence/ */\n//Given an integer array nums, return the length of the longest strictly increasing subsequence.\n//A subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, [3,6,2,7] is a subsequence of the array [0,3,1,6,2,2,7].\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\n var lengthOfLIS = function(nums) {\n    if(!nums || nums.length === 0) return 0;\n    let dp = [nums[0]];\n    for(let i = 1; i < nums.length; i++){\n        if(nums[i] > dp[dp.length - 1]){\n            dp.push(nums[i]);\n        }else{\n            let index = binarySearch(dp, nums[i]);\n            dp[index] = nums[i];\n        }\n    }\n    return dp.length;\n};\n    ",
          "compare_result": "000000000000000000000000000000000000000000000000000000",
          "title_slug": "longest-increasing-subsequence"
       },
       {
          "id": 595212482,
          "lang": "python",
          "time": "3 hours, 9 minutes",
          "timestamp": 1638327077,
          "status_display": "Accepted",
          "runtime": "3440 ms",
          "url": "/submissions/detail/595212482/",
          "is_pending": "Not Pending",
          "title": "Longest Increasing Subsequence",
          "memory": "13.8 MB",
          "code": "# https://leetcode.com/problems/longest-increasing-subsequence/\n#Given an integer array nums, return the length of the longest strictly increasing subsequence.\n#A subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, [3,6,2,7] is a subsequence of the array [0,3,1,6,2,2,7].\n\nclass Solution(object):\n    def lengthOfLIS(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        dp = [1] * len(nums)\n        for i in range(1, len(nums)):\n            for j in range(i):\n                if nums[i] > nums[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)",
          "compare_result": "111111111111111111111111111111111111111111111111111111",
          "title_slug": "longest-increasing-subsequence"
       },
       {
          "id": 595212441,
          "lang": "java",
          "time": "3 hours, 10 minutes",
          "timestamp": 1638327069,
          "status_display": "Accepted",
          "runtime": "51 ms",
          "url": "/submissions/detail/595212441/",
          "is_pending": "Not Pending",
          "title": "Longest Increasing Subsequence",
          "memory": "38.5 MB",
          "code": "/** https://leetcode.com/problems/longest-increasing-subsequence/ */\n//Given an integer array nums, return the length of the longest strictly increasing subsequence.\n//A subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, [3,6,2,7] is a subsequence of the array [0,3,1,6,2,2,7].\n\nclass Solution {\n    public int lengthOfLIS(int[] nums) {\n        if(nums.length == 0) return 0;\n        int[] dp = new int[nums.length];\n        dp[0] = 1;\n        int max = 1;\n        for(int i = 1; i < nums.length; i++) {\n            int max_val = 0;\n            for(int j = 0; j < i; j++) {\n                if(nums[i] > nums[j]) {\n                    max_val = Math.max(max_val, dp[j]);\n                }\n            }\n            dp[i] = max_val + 1;\n            max = Math.max(max, dp[i]);\n        }\n        return max;\n    }\n}",
          "compare_result": "111111111111111111111111111111111111111111111111111111",
          "title_slug": "longest-increasing-subsequence"
       },
       {
          "id": 595212366,
          "lang": "c",
          "time": "3 hours, 10 minutes",
          "timestamp": 1638327058,
          "status_display": "Accepted",
          "runtime": "92 ms",
          "url": "/submissions/detail/595212366/",
          "is_pending": "Not Pending",
          "title": "Longest Increasing Subsequence",
          "memory": "6.2 MB",
          "code": "/** https://leetcode.com/problems/longest-increasing-subsequence/ */\n//Given an integer array nums, return the length of the longest strictly increasing subsequence.\n//A subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, [3,6,2,7] is a subsequence of the array [0,3,1,6,2,2,7].\n\n\n\nint lengthOfLIS(int* nums, int numsSize){\n    if(numsSize == 0) return 0;\n    int dp[numsSize];\n    memset(dp, 0, sizeof(dp));\n    int max = 1;\n    dp[0] = 1;\n    for(int i = 1; i < numsSize; i++){\n        int max_num = 0;\n        for(int j = 0; j < i; j++){\n            if(nums[i] > nums[j]){\n                max_num = max_num > dp[j] ? max_num : dp[j];\n            }\n        }\n        dp[i] = max_num + 1;\n        max = max > dp[i] ? max : dp[i];\n    }\n    return max;\n}\n    ",
          "compare_result": "111111111111111111111111111111111111111111111111111111",
          "title_slug": "longest-increasing-subsequence"
       },
       {
          "id": 595212058,
          "lang": "javascript",
          "time": "3 hours, 11 minutes",
          "timestamp": 1638327015,
          "status_display": "Wrong Answer",
          "runtime": "N/A",
          "url": "/submissions/detail/595212058/",
          "is_pending": "Not Pending",
          "title": "Arithmetic Slices",
          "memory": "N/A",
          "code": "/** https://leetcode.com/problems/arithmetic-slices/ */\n//An integer array is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\n//For example, [1,3,5,7,9], [7,7,7,7], and [3,-1,-5,-9] are arithmetic sequences.\n//Given an integer array nums, return the number of arithmetic subarrays of nums.\n//A subarray is a contiguous subsequence of the array.\n\n/**\n * @param {number[]} nums\n * @return {number}\n */\n var numberOfArithmeticSlices = function(nums) {\n         let count = 0;\n    const dp = [];\n    for (let i = 0; i < nums.length; i++) {\n        dp[i] = [];\n        for (let j = 0; j <= i; j++) {\n            if (j === i) {\n                dp[i][j] = 1;\n            } else if (j === i - 1) {\n                dp[i][j] = 1;\n            } else {\n                dp[i][j] = dp[i - 1][j] + dp[i - 1][j + 1];\n            }\n        }\n        count += dp[i][0];\n    }\n    return count;\n};\n    ",
          "compare_result": "000000000000000",
          "title_slug": "arithmetic-slices"
       }
    ],
    "has_next": true,
    "last_key": "%7B%22pk%22%3A%20%7B%22N%22%3A%20%22595212058%22%7D%2C%20%22dt%22%3A%20%7B%22S%22%3A%20%222021-12-01T02%3A50%3A15.213371%2B0000%22%7D%2C%20%22sid%22%3A%20%7B%22N%22%3A%20%225508277%22%7D%7D"
 }