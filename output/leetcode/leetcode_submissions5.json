{
    "submissions_dump": [
       {
          "id": 595220086,
          "lang": "c",
          "time": "2 hours, 49 minutes",
          "timestamp": 1638328237,
          "status_display": "Accepted",
          "runtime": "0 ms",
          "url": "/submissions/detail/595220086/",
          "is_pending": "Not Pending",
          "title": "Number of Digit One",
          "memory": "5.4 MB",
          "code": "/** https://leetcode.com/problems/number-of-digit-one/ */\n\n\n\n/**\n * Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n.\n */\n\nint countDigitOne(int n){\n    int res = 0;\n    for(long long m = 1; m <= n; m *= 10){\n        int a = n/m, b = n%m;\n        res += (a+8)/10*m + (a%10 == 1)*(b+1);\n    }\n    return res;\n}\n    ",
          "compare_result": "11111111111111111111111111111111111111",
          "title_slug": "number-of-digit-one"
       },
       {
          "id": 595219719,
          "lang": "java",
          "time": "2 hours, 50 minutes",
          "timestamp": 1638328177,
          "status_display": "Accepted",
          "runtime": "0 ms",
          "url": "/submissions/detail/595219719/",
          "is_pending": "Not Pending",
          "title": "Number of Digit One",
          "memory": "35.6 MB",
          "code": "/** https://leetcode.com/problems/number-of-digit-one/ */\n\n/**\n * Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n.\n */\nclass Solution {\n    public int countDigitOne(int n) {\n        int res = 0;\n        for (long m = 1; m <= n; m *= 10) {\n            long a = n / m, b = n % m;\n            res += (a + 8) / 10 * m + (a % 10 == 1 ? b + 1 : 0);\n        }\n        return res;\n    }\n}",
          "compare_result": "11111111111111111111111111111111111111",
          "title_slug": "number-of-digit-one"
       },
       {
          "id": 595219276,
          "lang": "python",
          "time": "2 hours, 51 minutes",
          "timestamp": 1638328105,
          "status_display": "Runtime Error",
          "runtime": "N/A",
          "url": "/submissions/detail/595219276/",
          "is_pending": "Not Pending",
          "title": "Number of Digit One",
          "memory": "N/A",
          "code": "# https://leetcode.com/problems/number-of-digit-one/\n\n# count the total number of digit 1 appearing in all non-negative integers less than or equal to n.\nclass Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        if n == 0:\n            return 0\n        count = 0\n        for i in range(1, n + 1):\n            count += self.helper(i)\n        return count",
          "compare_result": "00000000000000000000000000000000000000",
          "title_slug": "number-of-digit-one"
       },
       {
          "id": 595219012,
          "lang": "javascript",
          "time": "2 hours, 52 minutes",
          "timestamp": 1638328064,
          "status_display": "Wrong Answer",
          "runtime": "N/A",
          "url": "/submissions/detail/595219012/",
          "is_pending": "Not Pending",
          "title": "Max Sum of Rectangle No Larger Than K",
          "memory": "N/A",
          "code": "/** https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/ */\n//Given an m x n matrix matrix and an integer k, return the max sum of a rectangle in the matrix such that its sum is no larger than k.\n\n/**\n * @param {number[][]} matrix\n * @param {number} k\n * @return {number}\n */\n var maxSumSubmatrix = function(matrix, k) {\n    let max = Number.NEGATIVE_INFINITY;\n        for (let i = 0; i < matrix.length; i++) {\n        for (let j = 0; j < matrix[0].length; j++) {\n            let sum = 0;\n            for (let x = i; x < matrix.length; x++) {\n                for (let y = j; y < matrix[0].length; y++) {\n                    sum += matrix[x][y];\n                    if (sum > max && sum <= k) {\n                        max = sum;\n                    }\n                }\n            }\n        }\n    }\n    return max;\n}\n",
          "compare_result": "111111111111011111110000011000011001011",
          "title_slug": "max-sum-of-rectangle-no-larger-than-k"
       },
       {
          "id": 595218879,
          "lang": "python",
          "time": "2 hours, 53 minutes",
          "timestamp": 1638328042,
          "status_display": "Wrong Answer",
          "runtime": "N/A",
          "url": "/submissions/detail/595218879/",
          "is_pending": "Not Pending",
          "title": "Max Sum of Rectangle No Larger Than K",
          "memory": "N/A",
          "code": "# https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/\n#Given an m x n matrix matrix and an integer k, return the max sum of a rectangle in the matrix such that its sum is no larger than k.\n\nclass Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        if not matrix or not matrix[0]:\n            return 0\n        n, m = len(matrix), len(matrix[0])\n        max_sum = 0\n        for i in range(n):\n            for j in range(i, n):\n                sum_list = [0 for _ in range(m)]\n                for k in range(j + 1):\n                    for l in range(m):\n                        sum_list[l] += matrix[k][l]\n                    sum_max = max(sum_list)\n                    if sum_max <= k:\n                        max_sum = max(max_sum, sum_max)\n        return max_sum\n    ",
          "compare_result": "000000000000000100000000000000000000000",
          "title_slug": "max-sum-of-rectangle-no-larger-than-k"
       },
       {
          "id": 595218806,
          "lang": "java",
          "time": "2 hours, 53 minutes",
          "timestamp": 1638328032,
          "status_display": "Wrong Answer",
          "runtime": "N/A",
          "url": "/submissions/detail/595218806/",
          "is_pending": "Not Pending",
          "title": "Max Sum of Rectangle No Larger Than K",
          "memory": "N/A",
          "code": "/** https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/ */\n//Given an m x n matrix matrix and an integer k, return the max sum of a rectangle in the matrix such that its sum is no larger than k.\n\nclass Solution {\n    public int maxSumSubmatrix(int[][] matrix, int k) {\n        int m = matrix.length;\n        if(m == 0) return 0;\n        int n = matrix[0].length;\n        if(n == 0) return 0;\n        int max = Integer.MIN_VALUE;\n        for(int i = 0; i < m; i++) {\n            int[] row = matrix[i];\n            for(int j = 0; j < n; j++) {\n                for(int l = i; l < m; l++) {\n                    int[] row2 = matrix[l];\n                    int sum = 0;\n                    for(int r = j; r < n; r++) {\n                        sum += row2[r];\n                        if(sum > k) break;\n                        if(sum > max) max = sum;\n                    }\n                }\n            }\n        }\n        return max;\n    }\n}\n    ",
          "compare_result": "101110100111111100100000001000000000000",
          "title_slug": "max-sum-of-rectangle-no-larger-than-k"
       },
       {
          "id": 595218739,
          "lang": "c",
          "time": "2 hours, 53 minutes",
          "timestamp": 1638328022,
          "status_display": "Wrong Answer",
          "runtime": "N/A",
          "url": "/submissions/detail/595218739/",
          "is_pending": "Not Pending",
          "title": "Max Sum of Rectangle No Larger Than K",
          "memory": "N/A",
          "code": "/** https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/ */\n//Given an m x n matrix matrix and an integer k, return the max sum of a rectangle in the matrix such that its sum is no larger than k.\n\n\n\nint maxSumSubmatrix(int** matrix, int matrixSize, int* matrixColSize, int k){\n    int i, j, m, n, sum, max = INT_MIN;\n    for(i = 0; i < matrixSize; i++){\n        for(j = i; j < matrixSize; j++){\n            sum = 0;\n            for(m = 0; m < matrixSize; m++){\n                for(n = 0; n < matrixColSize[m]; n++){\n                    sum += matrix[m][n];\n                }\n            }\n            if(sum <= k){\n                max = max > sum ? max : sum;\n            }\n        }\n    }\n    return max;\n}\n    ",
          "compare_result": "010000000000000000000000010000000000000",
          "title_slug": "max-sum-of-rectangle-no-larger-than-k"
       },
       {
          "id": 595218509,
          "lang": "javascript",
          "time": "2 hours, 53 minutes",
          "timestamp": 1638327988,
          "status_display": "Runtime Error",
          "runtime": "N/A",
          "url": "/submissions/detail/595218509/",
          "is_pending": "Not Pending",
          "title": "Longest Increasing Path in a Matrix",
          "memory": "N/A",
          "code": "/** https://leetcode.com/problems/longest-increasing-path-in-a-matrix/ */\n//Given an m x n integers matrix, return the length of the longest increasing path in matrix.\n//From each cell, you can either move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed).\n\n/**\n * @param {number[][]} matrix\n * @return {number}\n */\n var longestIncreasingPath = function(matrix) {\n         if(matrix.length == 0) return 0;\n    var max = 0;\n    for(var i = 0; i < matrix.length; i++){\n        for(var j = 0; j < matrix[i].length; j++){\n            max = Math.max(max, dfs(i, j, matrix));\n        }\n    }\n    return max;\n};\n    ",
          "compare_result": "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
          "title_slug": "longest-increasing-path-in-a-matrix"
       },
       {
          "id": 595218390,
          "lang": "python",
          "time": "2 hours, 54 minutes",
          "timestamp": 1638327973,
          "status_display": "Runtime Error",
          "runtime": "N/A",
          "url": "/submissions/detail/595218390/",
          "is_pending": "Not Pending",
          "title": "Longest Increasing Path in a Matrix",
          "memory": "N/A",
          "code": "# https://leetcode.com/problems/longest-increasing-path-in-a-matrix/\n#Given an m x n integers matrix, return the length of the longest increasing path in matrix.\n#From each cell, you can either move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed).\n\nclass Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        if not matrix or not matrix[0]:\n            return 0\n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        res = 0\n        for i in range(m):\n            for j in range(n):\n                self.dfs(matrix, i, j, m, n, dp)\n                res = max(res, dp[i][j])\n        return res",
          "compare_result": "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
          "title_slug": "longest-increasing-path-in-a-matrix"
       },
       {
          "id": 595218342,
          "lang": "java",
          "time": "2 hours, 54 minutes",
          "timestamp": 1638327965,
          "status_display": "Accepted",
          "runtime": "5 ms",
          "url": "/submissions/detail/595218342/",
          "is_pending": "Not Pending",
          "title": "Longest Increasing Path in a Matrix",
          "memory": "39 MB",
          "code": "/** https://leetcode.com/problems/longest-increasing-path-in-a-matrix/ */\n//Given an m x n integers matrix, return the length of the longest increasing path in matrix.\n//From each cell, you can either move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed).\n\nclass Solution {\n    public int longestIncreasingPath(int[][] matrix) {\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\n            return 0;\n        }\n        int m = matrix.length;\n        int n = matrix[0].length;\n        int[][] cache = new int[m][n];\n        int max = 1;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                max = Math.max(max, dfs(matrix, i, j, cache));\n            }\n        }\n        return max;\n    }\n    private int dfs(int[][] matrix, int i, int j, int[][] cache) {\n        if (cache[i][j] > 0) {\n            return cache[i][j];\n        }\n        int m = matrix.length;\n        int n = matrix[0].length;\n        int max = 1;\n        if (i > 0 && matrix[i - 1][j] > matrix[i][j]) {\n            max = Math.max(max, 1 + dfs(matrix, i - 1, j, cache));\n        }\n        if (i < m - 1 && matrix[i + 1][j] > matrix[i][j]) {\n            max = Math.max(max, 1 + dfs(matrix, i + 1, j, cache));\n        }\n        if (j > 0 && matrix[i][j - 1] > matrix[i][j]) {\n            max = Math.max(max, 1 + dfs(matrix, i, j - 1, cache));\n        }\n        if (j < n - 1 && matrix[i][j + 1] > matrix[i][j]) {\n            max = Math.max(max, 1 + dfs(matrix, i, j + 1, cache));\n        }\n        cache[i][j] = max;\n        return max;\n    }\n}",
          "compare_result": "111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
          "title_slug": "longest-increasing-path-in-a-matrix"
       },
       {
          "id": 595218285,
          "lang": "c",
          "time": "2 hours, 54 minutes",
          "timestamp": 1638327956,
          "status_display": "Compile Error",
          "runtime": "N/A",
          "url": "/submissions/detail/595218285/",
          "is_pending": "Not Pending",
          "title": "Longest Increasing Path in a Matrix",
          "memory": "N/A",
          "code": "/** https://leetcode.com/problems/longest-increasing-path-in-a-matrix/ */\n//Given an m x n integers matrix, return the length of the longest increasing path in matrix.\n//From each cell, you can either move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed).\n\n\n\nint longestIncreasingPath(int** matrix, int matrixSize, int* matrixColSize){\n    if (matrixSize == 0 || matrixColSize == 0) {\n        return 0;\n    }\n    int **dp = (int **)malloc(sizeof(int *) * matrixSize);\n    for (int i = 0; i < matrixSize; i++) {\n        dp[i] = (int *)malloc(sizeof(int) * matrixColSize[i]);\n    }\n    int max = 1;\n    for (int i = 0; i < matrixSize; i++) {\n        for (int j = 0; j < matrixColSize[i]; j++) {\n            dp[i][j] = 1;\n        }\n    }\n    for (int i = 0; i < matrixSize; i++) {\n        for (int j = 0; j < matrixColSize[i]; j++) {\n            for (int k = 0; k < 4; k++) {\n                int x = i + dx[k];\n                int y = j + dy[k];\n                if (x >= 0 && x < matrixSize && y >= 0 && y < matrixColSize[i] && matrix[x][y] > matrix[i][j]) {\n                    dp[i][j] = max(dp[i][j], dp[x][y] + 1);\n                }\n            }\n            max = max(max, dp[i][j]);\n        }\n    }\n    return max;\n    \n}\n    ",
          "compare_result": null,
          "title_slug": "longest-increasing-path-in-a-matrix"
       },
       {
          "id": 595217992,
          "lang": "javascript",
          "time": "2 hours, 55 minutes",
          "timestamp": 1638327913,
          "status_display": "Runtime Error",
          "runtime": "N/A",
          "url": "/submissions/detail/595217992/",
          "is_pending": "Not Pending",
          "title": "Frog Jump",
          "memory": "N/A",
          "code": "/** https://leetcode.com/problems/frog-jump/ */\n//A frog is crossing a river. The river is divided into some number of units, and at each unit, there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.\n//Given a list of stones' positions (in units) in sorted ascending order, determine if the frog can cross the river by landing on the last stone. Initially, the frog is on the first stone and assumes the first jump must be 1 unit.\n//If the frog's last jump was k units, its next jump must be either k - 1, k, or k + 1 units. The frog can only jump in the forward direction.\n\n/**\n * @param {number[]} stones\n * @return {boolean}\n */\n var canCross = function(stones) {\n         let map = new Map();\n    for(let i = 0; i < stones.length; i++) {\n        map.set(stones[i], new Set());\n    }\n    for(let i = 0; i < stones.length; i++) {\n        for(let j = i + 1; j < stones.length; j++) {\n            if(stones[j] - stones[i] <= 2) {\n                map.get(stones[i]).add(stones[j]);\n            }\n        }\n    }\n    let visited = new Set();\n    return dfs(0, map, visited);\n}\n    ",
          "compare_result": "000000000000000000000000000000000000000000000000000",
          "title_slug": "frog-jump"
       },
       {
          "id": 595217940,
          "lang": "python",
          "time": "2 hours, 55 minutes",
          "timestamp": 1638327905,
          "status_display": "Wrong Answer",
          "runtime": "N/A",
          "url": "/submissions/detail/595217940/",
          "is_pending": "Not Pending",
          "title": "Frog Jump",
          "memory": "N/A",
          "code": "# https://leetcode.com/problems/frog-jump/\n#A frog is crossing a river. The river is divided into some number of units, and at each unit, there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.\n#Given a list of stones' positions (in units) in sorted ascending order, determine if the frog can cross the river by landing on the last stone. Initially, the frog is on the first stone and assumes the first jump must be 1 unit.\n#If the frog's last jump was k units, its next jump must be either k - 1, k, or k + 1 units. The frog can only jump in the forward direction.\n\nclass Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        if len(stones) == 1:\n            return True\n        if stones[1] != 1:\n            return False\n        jumps = set([1])\n        for i in range(2, len(stones)):\n            for jump in jumps.copy():\n                if stones[i] == stones[i - 1] + jump:\n                    jumps.add(jump)\n                if stones[i] == stones[i - 1] + jump - 1:\n                    jumps.add(jump - 1)\n                if stones[i] == stones[i - 1] + jump + 1:\n                    jumps.add(jump + 1)\n        return stones[-1] in jumps",
          "compare_result": "010111000011110010000000000001111111111100011110000",
          "title_slug": "frog-jump"
       },
       {
          "id": 595217885,
          "lang": "java",
          "time": "2 hours, 55 minutes",
          "timestamp": 1638327897,
          "status_display": "Wrong Answer",
          "runtime": "N/A",
          "url": "/submissions/detail/595217885/",
          "is_pending": "Not Pending",
          "title": "Frog Jump",
          "memory": "N/A",
          "code": "/** https://leetcode.com/problems/frog-jump/ */\n//A frog is crossing a river. The river is divided into some number of units, and at each unit, there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.\n//Given a list of stones' positions (in units) in sorted ascending order, determine if the frog can cross the river by landing on the last stone. Initially, the frog is on the first stone and assumes the first jump must be 1 unit.\n//If the frog's last jump was k units, its next jump must be either k - 1, k, or k + 1 units. The frog can only jump in the forward direction.\n\nclass Solution {\n    public boolean canCross(int[] stones) {\n        if (stones == null || stones.length == 0) {\n            return false;\n        }\n        if (stones.length == 1) {\n            return true;\n        }\n        Map<Integer, Set<Integer>> jumpMap = new HashMap<>();\n        for (int i = 0; i < stones.length; i++) {\n            jumpMap.put(stones[i], new HashSet<>());\n        }\n        jumpMap.get(stones[0]).add(1);\n        for (int i = 1; i < stones.length; i++) {\n            for (int j : jumpMap.get(stones[i - 1])) {\n                int jump = stones[i] - stones[i - 1] + j;\n                if (jump > 0 && jumpMap.get(stones[i]).add(jump)) {\n                    if (jump == stones[stones.length - 1] - stones[i]) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n}",
          "compare_result": "110011000101110111000000000001111111111100010111000",
          "title_slug": "frog-jump"
       },
       {
          "id": 595217790,
          "lang": "c",
          "time": "2 hours, 55 minutes",
          "timestamp": 1638327885,
          "status_display": "Wrong Answer",
          "runtime": "N/A",
          "url": "/submissions/detail/595217790/",
          "is_pending": "Not Pending",
          "title": "Frog Jump",
          "memory": "N/A",
          "code": "/** https://leetcode.com/problems/frog-jump/ */\n//A frog is crossing a river. The river is divided into some number of units, and at each unit, there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.\n//Given a list of stones' positions (in units) in sorted ascending order, determine if the frog can cross the river by landing on the last stone. Initially, the frog is on the first stone and assumes the first jump must be 1 unit.\n//If the frog's last jump was k units, its next jump must be either k - 1, k, or k + 1 units. The frog can only jump in the forward direction.\n\n\n\nbool canCross(int* stones, int stonesSize){\n    // Write your code here\n    int *visited = (int *)malloc(sizeof(int) * stonesSize);\n    for(int i = 0; i < stonesSize; i++)\n        visited[i] = 0;\n    visited[0] = 1;\n    for(int i = 0; i < stonesSize; i++){\n        if(visited[i] == 1){\n            for(int j = i + 1; j < stonesSize; j++){\n                if(j - i == 1)\n                    visited[j] = 1;\n                else if(j - i == 2)\n                    visited[j] = visited[j - 1];\n                else if(j - i > 2 && visited[j - 1] == 1)\n                    visited[j] = 1;\n                if(visited[stonesSize - 1] == 1)\n                    return true;\n            }\n        }\n    }\n    return false;\n}\n    ",
          "compare_result": "101000111110001101111111111110000000000011100001111",
          "title_slug": "frog-jump"
       },
       {
          "id": 595217630,
          "lang": "javascript",
          "time": "2 hours, 56 minutes",
          "timestamp": 1638327862,
          "status_display": "Wrong Answer",
          "runtime": "N/A",
          "url": "/submissions/detail/595217630/",
          "is_pending": "Not Pending",
          "title": "Count The Repetitions",
          "memory": "N/A",
          "code": "/** https://leetcode.com/problems/count-the-repetitions/ */\n//We define str = [s, n] as the string str which consists of the string s concatenated n times.\n//For example, str == [\"abc\", 3] ==\"abcabcabc\".\n//We define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n//For example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters.\n//You are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].\n//Return the maximum integer m such that str = [str2, m] can be obtained from str1.\n\n/**\n * @param {string} s1\n * @param {number} n1\n * @param {string} s2\n * @param {number} n2\n * @return {number}\n */\n var getMaxRepetitions = function(s1, n1, s2, n2) {\n     let s1_len = s1.length;\n     let s2_len = s2.length;\n     let s1_idx = 0;\n     let s2_idx = 0;\n     let count = 0;\n     for(let i = 0; i < n1; i++) {\n         let s1_c = s1[s1_idx];\n         let s2_c = s2[s2_idx];\n         if(s1_c === s2_c) {\n             s2_idx++;\n             if(s2_idx === s2_len) {\n                 count++;\n                 s2_idx = 0;\n             }\n         }\n         s1_idx++;\n         if(s1_idx === s1_len) {\n             s1_idx = 0;\n         }\n     }\n     return count / n2;\n }\n    ",
          "compare_result": "0000000001100110000100000000000010000010000000000",
          "title_slug": "count-the-repetitions"
       },
       {
          "id": 595217537,
          "lang": "java",
          "time": "2 hours, 56 minutes",
          "timestamp": 1638327849,
          "status_display": "Time Limit Exceeded",
          "runtime": "N/A",
          "url": "/submissions/detail/595217537/",
          "is_pending": "Not Pending",
          "title": "Count The Repetitions",
          "memory": "N/A",
          "code": "/** https://leetcode.com/problems/count-the-repetitions/ */\n//We define str = [s, n] as the string str which consists of the string s concatenated n times.\n//For example, str == [\"abc\", 3] ==\"abcabcabc\".\n//We define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n//For example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters.\n//You are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].\n//Return the maximum integer m such that str = [str2, m] can be obtained from str1.\n\nclass Solution {\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\n        if (s1.length() == 0 || s2.length() == 0) {\n            return 0;\n        }\n        int count = 0;\n        int i = 0;\n        int j = 0;\n        int m = 0;\n        while (m < n1) {\n            if (s1.charAt(i) == s2.charAt(j)) {\n                j++;\n                if (j == s2.length()) {\n                    j = 0;\n                    count++;\n                }\n            }\n            i++;\n            if (i == s1.length()) {\n                i = 0;\n                m++;\n            }\n        }\n        return count / n2;\n    }\n}",
          "compare_result": "1111111111111111111111111111111111111110000000000",
          "title_slug": "count-the-repetitions"
       },
       {
          "id": 595217395,
          "lang": "python",
          "time": "2 hours, 56 minutes",
          "timestamp": 1638327828,
          "status_display": "Runtime Error",
          "runtime": "N/A",
          "url": "/submissions/detail/595217395/",
          "is_pending": "Not Pending",
          "title": "Count The Repetitions",
          "memory": "N/A",
          "code": "# https://leetcode.com/problems/count-the-repetitions/\n#We define str = [s, n] as the string str which consists of the string s concatenated n times.\n#For example, str == [\"abc\", 3] ==\"abcabcabc\".\n#We define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n#For example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters.\n#You are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].\n#Return the maximum integer m such that str = [str2, m] can be obtained from str1.\n\nclass Solution(object):\n    def getMaxRepetitions(self, s1, n1, s2, n2):\n        \"\"\"\n        :type s1: str\n        :type n1: int\n        :type s2: str\n        :type n2: int\n        :rtype: int\n        \"\"\"\n        count = 0\n        s1_idx = 0\n        s2_idx = 0\n        while count < n1:\n            if s1[s1_idx] == s2[s2_idx]:\n                s2_idx += 1\n                if s2_idx == n2:\n                    s2_idx = 0\n                    count += 1\n            s1_idx += 1\n            if s1_idx == n1:\n                s1_idx = 0\n        return count % n2",
          "compare_result": "0000000000000000000000000000000000000000000000000",
          "title_slug": "count-the-repetitions"
       },
       {
          "id": 595217317,
          "lang": "c",
          "time": "2 hours, 56 minutes",
          "timestamp": 1638327814,
          "status_display": "Time Limit Exceeded",
          "runtime": "N/A",
          "url": "/submissions/detail/595217317/",
          "is_pending": "Not Pending",
          "title": "Count The Repetitions",
          "memory": "N/A",
          "code": "/** https://leetcode.com/problems/count-the-repetitions/ */\n//We define str = [s, n] as the string str which consists of the string s concatenated n times.\n//For example, str == [\"abc\", 3] ==\"abcabcabc\".\n//We define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n//For example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters.\n//You are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].\n//Return the maximum integer m such that str = [str2, m] can be obtained from str1.\n\n\n\nint getMaxRepetitions(char * s1, int n1, char * s2, int n2){\n    int s1_len = strlen(s1);\n    int s2_len = strlen(s2);\n    int i = 0, j = 0, cnt = 0;\n    int cnt_s2 = 0;\n    while(cnt < n1){\n        if(s1[i] == s2[j]){\n            cnt++;\n            j++;\n            if(j == s2_len){\n                cnt_s2++;\n                j = 0;\n            }\n        }\n        i++;\n        if(i == s1_len){\n            i = 0;\n            cnt = 0;\n        }\n    }\n    return cnt_s2 * n2 / n1;\n    \n}\n    ",
          "compare_result": "0000000000000000000000000000000000000000000000000",
          "title_slug": "count-the-repetitions"
       },
       {
          "id": 595216819,
          "lang": "javascript",
          "time": "2 hours, 58 minutes",
          "timestamp": 1638327733,
          "status_display": "Runtime Error",
          "runtime": "N/A",
          "url": "/submissions/detail/595216819/",
          "is_pending": "Not Pending",
          "title": "Count Numbers with Unique Digits",
          "memory": "N/A",
          "code": "/** https://leetcode.com/problems/count-numbers-with-unique-digits/ */\n//Given an integer n, return the count of all numbers with unique digits, x, where 0 <= x < 10n.\n\nclass Solution {\n    public int countNumbersWithUniqueDigits(int n) {\n        int[] dp = new int[n + 1];\n        dp[0] = 1;\n        dp[1] = 10;\n        for (int i = 2; i <= n; i++) {\n            dp[i] = dp[i - 1] * (11 - i);\n        }\n        int ans = dp[n];\n        for (int i = 1; i <= 9; i++) {\n            ans += dp[n - 1];\n        }\n        return ans;\n    }\n}\n    ",
          "compare_result": "000000000",
          "title_slug": "count-numbers-with-unique-digits"
       }
    ],
    "has_next": true,
    "last_key": "%7B%22pk%22%3A%20%7B%22N%22%3A%20%22595216819%22%7D%2C%20%22dt%22%3A%20%7B%22S%22%3A%20%222021-12-01T03%3A02%3A13.486277%2B0000%22%7D%2C%20%22sid%22%3A%20%7B%22N%22%3A%20%225508277%22%7D%7D"
 }